\input texinfo.tex
@c %**start of header
@setfilename cclanguage.info
@settitle CCLanguage
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Document specific macros.
@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cclanguage

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------------------

@set PackageAutoconfPrefix              CCLANGUAGE
@set PackagePkgconfigModule             cclanguage
@set PackageLibsVar                     @env{CCLANGUAGE_LIBS}
@set PackageCflagsVar                   @env{CCLANGUAGE_CFLAGS}
@c This is the stem of the library in "libcclanguage.so".
@set PackageLibstem                     cclanguage
@set PackageApiPrefixLower              cct_
@set PackageApiPrefixUpper              CCT_

@set PackageHeader                      cclanguage.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set CCLibrariesExamplesUrl    @url{https://github.com/marcomaggi/cclibraries-examples}

@c ------------------------------------------------------------------------

@set CCLibrariesExamples                CCLibraries Examples

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing language adaptations and extensions.  It implements basic definitions used by all the
packages in the CCLibraries project.

The package supports @posix{} platforms.

The code is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cclibraries: (cclibraries).       CCLibraries, C11 language core header file.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* compiler::                    Compiler facilities.
* macros::                      Helper macros.
* typedefs::                    Common type definitions and related macros.
* variadic::                    Variadic preprocessor macros.
* structs::                     Defining data structure handling @api{}.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing language adaptations and extensions.  It implements basic definitions used by all the
packages in the CCLibraries project.

The package supports @posix{} platforms.

The package installs multiple C language header files, of which @file{cclanguage.h} is the main one;
it gives access to the whole @api{}.  All the macro definitions are prefixed with @code{CCLIB_},
@code{cclib_} or @code{cclang_}; all the type names are prefixed with @code{cclib_} and suffixed
with @code{_t}.

Usage examples for this package, and all the CCLibraries packages, are available in the companion
package CCLibraries Examples, @ref{references, CCLibraries Examples} for details.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cclang_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int cclang_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cclang_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int cclang_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node compiler
@chapter Compiler facilities


The interface to the C11 language compiler are defined in the header file
@file{cclanguage-compiler.h}; this header is included by @file{cclanguage.h}.

@menu
* compiler attributes::         Compiler attributes for functions.
* compiler visibility::         Functions and variables visibility declarations.
@end menu

@c page
@node compiler attributes
@section Compiler attributes for functions


@value{PACKAGE} tries to determine, through the C preprocessor macros, which function attributes are
implemented by the compiler and defines the following macros accordingly.  If an attribute is not
implemented: the corresponding macro is defined to expand to the empty string.

A typical function prototype declaration for a function using the facilities of CCLibraries looks
like this:

@example
cclib_decl void * cce_sys_malloc (cce_destination_t L, size_t size)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
  CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
  CCLIB_FUNC_ATTRIBUTE_LEAF;
@end example

@noindent
while a @code{static} and @code{inline} function definition looks like this:

@example
CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
CCLIB_FUNC_ATTRIBUTE_PURE
CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
static inline cce_handler_t *
cce_clean_handler_handler (cce_clean_handler_t * const H)
@{
  ...
@}
@end example


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
Expand into:

@example
__attribute__((__always_inline__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONST
Expand into:

@example
__attribute__((__const__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONSTRUCTOR
Expand into:

@example
__attribute__((__constructor__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLEXPORT
Expand into:

@example
__attribute__((__dllexport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLIMPORT
Expand into:

@example
__attribute__((__dllimport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_FORMAT (...)
Expand into:

@example
__attribute__((__format__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_HOT
Expand into:

@example
__attribute__((__hot__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_LEAF
Expand into:

@example
__attribute__((__leaf__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NONNULL (...)
Expand into:

@example
__attribute__((__nonnull__(__VA_ARGS__)))
@end example

We can use this macro as follows:

@example
cclib_decl void my_func (int * dst, int * src)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1,2);
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NORETURN
Expand into:

@example
__attribute__((__noreturn__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_PURE
Expand into:

@example
__attribute__((__pure__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
Expand into:

@example
__attribute__((__returns_nonnull__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_UNUSED
Expand into:

@example
__attribute__((__unused__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_USED
Expand into:

@example
__attribute__((__used__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_VISIBILITY (...)
Expand into:

@example
__attribute__((__visibility__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  It expands into:

@example
CCLIB_FUNC_ATTRIBUTE_UNUSED
@end example
@end deffn

@c page
@node compiler visibility
@section Functions and variables visibility declarations


@deffn {Preprocessor Macro} cclib_decl
Expand into the qualifiers for a public @api{} declaration.  When using the @gnu{} C Compiler on a
@posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("default") extern
@end example
@end deffn


@deffn {Preprocessor Macro} cclib_private_decl
Expand into the qualifiers for a private @api{} declaration: entities qualified with this macro are
meant to be visible only inside the namespace of a shared library.  When using the @gnu{} C Compiler
on a @posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("hidden")  extern
@end example
@end deffn

@c page
@node macros
@chapter Helper macros


The following definitions are in the header file @file{cclanguage.h}.


@deffn {Preprocessor Macro} CCLIB_CAST (@var{TYPE}, @var{X}, @var{Y})
Type cast helper.  It expands into:

@example
@var{TYPE} @var{X} = (@var{TYPE}) (@var{Y})
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_condition_t * K = cce_condition(L);
cce_exceptional_condition_object_t(ccevents_timeval_invalid) * C = \
  (cce_exceptional_condition_object_t(ccevents_timeval_invalid) *) K;
@end example

@noindent
we can write:

@example
cce_condition_t * K = cce_condition(L);
CCLIB_PC(cce_exceptional_condition_object_t(ccevents_timeval_invalid), C, K);
@end example

@noindent
or:

@example
CCLIB_PC(cce_exceptional_condition_object_t(ccevents_timeval_invalid), C, cce_condition(L));
@end example
@end deffn

@c page
@node typedefs
@chapter Common type definitions and related macros


The C11 language facilities for type definitions are defined in the header file
@file{cclanguage-typedefs.h}; this header is included by @file{cclanguage.h}.

@menu
* typedefs aliases::            Aliases of @posix{} standard types.
* typedefs opaque::             Opaque data structures handling.
@end menu

@c page
@node typedefs aliases
@section Aliases of @posix{} standard types


All the definitions documented in this section are defined in the header file
@file{cclanguage-typedefs.h}; this header file is included by @file{cclanguage.h}.

@menu
* typedefs aliases macros::     Generic type--handling macros.
* typedefs aliases sint8::      Type alias with stem @samp{sint8}.
* typedefs aliases uint8::      Type alias with stem @samp{uint8}.
* typedefs aliases sint16::     Type alias with stem @samp{sint16}.
* typedefs aliases uint16::     Type alias with stem @samp{uint16}.
* typedefs aliases sint32::     Type alias with stem @samp{sint32}.
* typedefs aliases uint32::     Type alias with stem @samp{uint32}.
* typedefs aliases sint64::     Type alias with stem @samp{sint64}.
* typedefs aliases uint64::     Type alias with stem @samp{uint64}.
* typedefs aliases byte::       Type alias with stem @samp{byte}.
* typedefs aliases octet::      Type alias with stem @samp{octet}.
* typedefs aliases word::       Type alias with stem @samp{word}.
* typedefs aliases char::       Type alias with stem @samp{char}.
* typedefs aliases schar::      Type alias with stem @samp{schar}.
* typedefs aliases uchar::      Type alias with stem @samp{uchar}.
* typedefs aliases sshrt::      Type alias with stem @samp{sshrt}.
* typedefs aliases ushrt::      Type alias with stem @samp{ushrt}.
* typedefs aliases sint::       Type alias with stem @samp{sint}.
* typedefs aliases uint::       Type alias with stem @samp{uint}.
* typedefs aliases slong::      Type alias with stem @samp{slong}.
* typedefs aliases ulong::      Type alias with stem @samp{ulong}.
* typedefs aliases sllong::     Type alias with stem @samp{sllong}.
* typedefs aliases ullong::     Type alias with stem @samp{ullong}.
* typedefs aliases sintmax::    Type alias with stem @samp{sintmax}.
* typedefs aliases uintmax::    Type alias with stem @samp{uintmax}.
* typedefs aliases sintptr::    Type alias with stem @samp{sintptr}.
* typedefs aliases uintptr::    Type alias with stem @samp{uintptr}.
* typedefs aliases ptrdiff::    Type alias with stem @samp{ptrdiff}.
* typedefs aliases ssize::      Type alias with stem @samp{ssize}.
* typedefs aliases usize::      Type alias with stem @samp{usize}.
* typedefs aliases off::        Type alias with stem @samp{off}.
* typedefs aliases wchar::      Type alias with stem @samp{wchar}.
* typedefs aliases wint::       Type alias with stem @samp{wint}.
* typedefs aliases float::      Type alias with stem @samp{float}.
* typedefs aliases double::     Type alias with stem @samp{double}.
* typedefs aliases ldouble::    Type alias with stem @samp{ldouble}.
* typedefs aliases void::       Type alias with stem @samp{void}.
@end menu

@c ------------------------------------------------------------------------

@macro TypedefAliasLimits{STEM, stem}
@deftypefn {Preprocessor Macro} cclib_\stem\_t cclib_min_\stem\ (void)
@deftypefnx {Preprocessor Macro} cclib_\stem\_t cclib_max_\stem\ (void)
Constant limits for the type @objtype{cclib_\stem\_t}.
@end deftypefn


@end macro

@c ------------------------------------------------------------------------

@macro TypedefAliasSizeof{STEM, stem}
@deftypefn {Preprocessor Macro} int cclib_sizeof_\stem\ (void)
The size in bytes of the type @objtype{cclib_\stem\_t}.
@end deftypefn


@end macro

@c ------------------------------------------------------------------------

@macro TypedefAliasCast{stem}
@deftypefn {Preprocessor Macro} cclib_\stem\_t cclib_\stem\ (@var{EXPR})
Cast the result of @var{EXPR} to @objtype{cclib_\stem\_t}.
@end deftypefn


@end macro

@c ------------------------------------------------------------------------

@macro TypedefAliasPri{STEM, stem}
@deftypefn {Preprocessor Macro} {char const *} cclib_pri_\stem\ (void)
The @cfunc{printf} format specifier of the type @objtype{cclib_\stem\_t}: a string without the
leading @samp{%} symbol.
@end deftypefn


@end macro

@macro TypedefAliasPrintfCast{stem}
@deftypefn {Preprocessor Macro} cclib_XX_t cclib_\stem\_printf_cast (cclib_\stem\_t @var{EXPR})
If needed convert @var{VALUE} to another type before being printed with functions like
@cfunc{printf}; this macro does that with the result of the expression @var{EXPR}.  The resulting
type @objtype{cclib_XX_t} is the one that matches the result of @cfunc{cclib_pri_\stem\}.
@end deftypefn


@end macro

@c ------------------------------------------------------------------------

@macro TypedefAliasConst{stem}
@deftypefn {Preprocessor Macro} cclib_\stem\_t cclib_\stem\_const (@var{CONST_VALUE})
Declare a constant, hard--coded, compile--time, value of type @objtype{cclib_\stem\_t}.
@end deftypefn


@end macro


@c page
@node typedefs aliases macros
@subsection Generic type--handling macros


The following preprocessor macros handle all the type aliases defined by @value{PACKAGE} with the
argument @var{STEM}.  Given the type @objtype{cclib_sint8_t}, its stem is @samp{sint8}; given the
type @objtype{cclib_ptrdiff_t}, its stem is @samp{ptrdiff}; and so on.


@defmac cclib_type_t (@var{STEM})
Expand into one of the @code{cclib_@var{STEM}_t} types.  The expansion is:

@example
cclib_ ## STEM ## _t
@end example
@end defmac


@deftypefn {Preprocessor Macro} {cclib_@var{STEM}_t} cclib_type_max (@var{STEM})
Expand into the value of type @objtype{cclib_@var{STEM}_t} representing the maximum value in a type
range.  The expansion body is:

@example
(cclib_max_ ## @var{STEM}())
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {cclib_@var{STEM}_t} cclib_type_min (@var{STEM})
Expand into the value of type @objtype{cclib_@var{STEM}_t} representing the minimum value in a type
range.  The expansion body is:

@example
(cclib_min_ ## @var{STEM}())
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {int} cclib_type_sizeof (@var{STEM})
Expand into a constant integer value representing the size of a type in bytes.  The expansion body
is:

@example
(cclib_sizeof_ ## @var{STEM}())
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {char const *} cclib_type_pri (@var{STEM})
Expand into a statically allocated, @asciiz{} string representing the @cfunc{printf} format
specifier for @var{STEM}, without the leading @samp{%} character.  The expansion body is:

@example
(cclib_pri_ ## @var{STEM}())
@end example
@end deftypefn


@defmac cclib_type_printf_cast (@var{STEM}, @var{EXPR})
Values of some types need to be converted to another type before being printed with functions like
@cfunc{printf}; this macro does that with the result of the expression @var{EXPR}.  The expansion
is:

@example
(cclib_ ## STEM ## _printf_cast(EXPR))
@end example

For example, to print a @objtype{cclib_float_t} we can do:

@example
cclib_char_t    buffer[1024];

snprintf(buffer, 1024, "%" cclib_type_pri(float),
         cclib_type_printf_cast(float, cclib_type_max(float)));
@end example
@end defmac

@deftypefn {Preprocessor Macro} {cclib_@var{STEM}_t} cclib_type_cast (@var{STEM}, @var{EXPR})
Cast the result of @var{EXPR} to @var{STEM}'s type.  The expansion is:

@example
((cclib_type_t(@var{STEM})(@var{EXPR}))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {cclib_@var{STEM}_t} cclib_type_const (@var{STEM}, @var{CONST_VALUE})
Expand to an expression evaluating @var{CONST_VALUE} as a constant, hard--coded, value of type
@objtype{cclib_@var{STEM}_t}.  The expansion is:

@example
(cclib_type_cast(STEM)(cclib_ ## @var{STEM} ## _const(@var{CONST_VALUE})))
@end example

For example, if the type is an integer and @var{CONST_VALUE} has size different from an
@objtype{int}: this macro appends to @var{CONST_VALUE} the appropriate suffix @code{L} or @code{LL}.
@end deftypefn

@c page
@node typedefs aliases sint8
@subsection Type alias with stem @samp{sint8}


@deftp {Typedef} cclib_sint8_t
An alias for @objtype{int8_t}.
@end deftp


@TypedefAliasLimits{SINT8, sint8}
@TypedefAliasSizeof{SINT8, sint8}
@TypedefAliasCast{sint8}
@TypedefAliasPri{SINT8, sint8}
@TypedefAliasPrintfCast{sint8}
@TypedefAliasConst{sint8}

@c page
@node typedefs aliases uint8
@subsection Type alias with stem @samp{uint8}


@deftp {Typedef} cclib_uint8_t
An alias for @objtype{uint8_t}.
@end deftp


@TypedefAliasLimits{UINT8, uint8}
@TypedefAliasSizeof{UINT8, uint8}
@TypedefAliasCast{uint8}
@TypedefAliasPri{UINT8, uint8}
@TypedefAliasPrintfCast{uint8}
@TypedefAliasConst{uint8}

@c page
@node typedefs aliases sint16
@subsection Type alias with stem @samp{sint16}


@deftp {Typedef} cclib_sint16_t
An alias for @objtype{int16_t}.
@end deftp


@TypedefAliasLimits{SINT16, sint16}
@TypedefAliasSizeof{SINT16, sint16}
@TypedefAliasCast{sint16}
@TypedefAliasPri{SINT16, sint16}
@TypedefAliasPrintfCast{sint16}
@TypedefAliasConst{sint16}

@c page
@node typedefs aliases uint16
@subsection Type alias with stem @samp{uint16}


@deftp {Typedef} cclib_uint16_t
An alias for @objtype{uint16_t}.
@end deftp


@TypedefAliasLimits{UINT16, uint16}
@TypedefAliasSizeof{UINT16, uint16}
@TypedefAliasCast{uint16}
@TypedefAliasPri{UINT16, uint16}
@TypedefAliasPrintfCast{uint16}
@TypedefAliasConst{uint16}

@c page
@node typedefs aliases sint32
@subsection Type alias with stem @samp{sint32}


@deftp {Typedef} cclib_sint32_t
An alias for @objtype{int32_t}.
@end deftp


@TypedefAliasLimits{SINT32, sint32}
@TypedefAliasSizeof{SINT32, sint32}
@TypedefAliasCast{sint32}
@TypedefAliasPri{SINT32, sint32}
@TypedefAliasPrintfCast{sint32}
@TypedefAliasConst{sint32}

@c page
@node typedefs aliases uint32
@subsection Type alias with stem @samp{uint32}


@deftp {Typedef} cclib_uint32_t
An alias for @objtype{uint32_t}.
@end deftp


@TypedefAliasLimits{UINT32, uint32}
@TypedefAliasSizeof{UINT32, uint32}
@TypedefAliasCast{uint32}
@TypedefAliasPri{UINT32, uint32}
@TypedefAliasPrintfCast{uint32}
@TypedefAliasConst{uint32}

@c page
@node typedefs aliases sint64
@subsection Type alias with stem @samp{sint64}


@deftp {Typedef} cclib_sint64_t
An alias for @objtype{int64_t}.
@end deftp


@TypedefAliasLimits{SINT64, sint64}
@TypedefAliasSizeof{SINT64, sint64}
@TypedefAliasCast{sint64}
@TypedefAliasPri{SINT64, sint64}
@TypedefAliasPrintfCast{sint64}
@TypedefAliasConst{sint64}

@c page
@node typedefs aliases uint64
@subsection Type alias with stem @samp{uint64}


@deftp {Typedef} cclib_uint64_t
An alias for @objtype{uint64_t}.
@end deftp


@TypedefAliasLimits{UINT64, uint64}
@TypedefAliasSizeof{UINT64, uint64}
@TypedefAliasCast{uint64}
@TypedefAliasPri{UINT64, uint64}
@TypedefAliasPrintfCast{uint64}
@TypedefAliasConst{uint64}

@c page
@node typedefs aliases byte
@subsection Type alias with stem @samp{byte}


@deftp {Typedef} cclib_byte_t
An alias for @objtype{cclib_sint8_t}.
@end deftp


@TypedefAliasLimits{BYTE, byte}
@TypedefAliasSizeof{BYTE, byte}
@TypedefAliasCast{byte}
@TypedefAliasPri{BYTE, byte}
@TypedefAliasPrintfCast{byte}
@TypedefAliasConst{byte}

@c page
@node typedefs aliases octet
@subsection Type alias with stem @samp{octet}


@deftp {Typedef} cclib_octet_t
An alias for @objtype{cclib_uint8_t}.
@end deftp


@TypedefAliasLimits{OCTET, octet}
@TypedefAliasSizeof{OCTET, octet}
@TypedefAliasCast{octet}
@TypedefAliasPri{OCTET, octet}
@TypedefAliasPrintfCast{octet}
@TypedefAliasConst{octet}

@c page
@node typedefs aliases word
@subsection Type alias with stem @samp{word}


@deftp {Typedef} cclib_word_t
An alias for the type @objtype{cclib_sintXX_t} whose size equals the size of @code{void *}; it is
meant to be the integer capable of storing a machine word.
@end deftp


@TypedefAliasLimits{WORD, word}
@TypedefAliasSizeof{WORD, word}
@TypedefAliasCast{word}
@TypedefAliasPri{WORD, word}
@TypedefAliasPrintfCast{word}
@TypedefAliasConst{word}

@c page
@node typedefs aliases char
@subsection Type alias with stem @samp{char}


@deftp {Typedef} cclib_char_t
An alias for @objtype{char}.
@end deftp


@TypedefAliasLimits{CHAR, char}
@TypedefAliasSizeof{CHAR, char}
@TypedefAliasCast{char}
@TypedefAliasPri{CHAR, char}
@TypedefAliasPrintfCast{char}
@TypedefAliasConst{char}

@c page
@node typedefs aliases schar
@subsection Type alias with stem @samp{schar}


@deftp {Typedef} cclib_schar_t
An alias for @objtype{signed char}.
@end deftp


@TypedefAliasLimits{SCHAR, schar}
@TypedefAliasSizeof{SCHAR, schar}
@TypedefAliasCast{schar}
@TypedefAliasPri{SCHAR, schar}
@TypedefAliasPrintfCast{schar}
@TypedefAliasConst{schar}

@c page
@node typedefs aliases uchar
@subsection Type alias with stem @samp{uchar}


@deftp {Typedef} cclib_uchar_t
An alias for @objtype{unsigned char}.
@end deftp


@TypedefAliasLimits{UCHAR, uchar}
@TypedefAliasSizeof{UCHAR, uchar}
@TypedefAliasCast{uchar}
@TypedefAliasPri{UCHAR, uchar}
@TypedefAliasPrintfCast{uchar}
@TypedefAliasConst{uchar}

@c page
@node typedefs aliases sshrt
@subsection Type alias with stem @samp{sshrt}


@deftp {Typedef} cclib_sshrt_t
An alias for @objtype{signed short int}.
@end deftp


@TypedefAliasLimits{SSHRT, sshrt}
@TypedefAliasSizeof{SSHRT, sshrt}
@TypedefAliasCast{sshrt}
@TypedefAliasPri{SSHRT, sshrt}
@TypedefAliasPrintfCast{sshrt}
@TypedefAliasConst{sshrt}

@c page
@node typedefs aliases ushrt
@subsection Type alias with stem @samp{ushrt}


@deftp {Typedef} cclib_ushrt_t
An alias for @objtype{unsigned short int}.
@end deftp


@TypedefAliasLimits{USHRT, ushrt}
@TypedefAliasSizeof{USHRT, ushrt}
@TypedefAliasCast{ushrt}
@TypedefAliasPri{USHRT, ushrt}
@TypedefAliasPrintfCast{ushrt}
@TypedefAliasConst{ushrt}

@c page
@node typedefs aliases sint
@subsection Type alias with stem @samp{sint}


@deftp {Typedef} cclib_sint_t
An alias for @objtype{signed int}.
@end deftp


@TypedefAliasLimits{SINT, sint}
@TypedefAliasSizeof{SINT, sint}
@TypedefAliasCast{sint}
@TypedefAliasPri{SINT, sint}
@TypedefAliasPrintfCast{sint}
@TypedefAliasConst{sint}

@c page
@node typedefs aliases uint
@subsection Type alias with stem @samp{uint}


@deftp {Typedef} cclib_uint_t
An alias for @objtype{unsigned int}.
@end deftp


@TypedefAliasLimits{UINT, uint}
@TypedefAliasSizeof{UINT, uint}
@TypedefAliasCast{uint}
@TypedefAliasPri{UINT, uint}
@TypedefAliasPrintfCast{uint}
@TypedefAliasConst{uint}

@c page
@node typedefs aliases slong
@subsection Type alias with stem @samp{slong}


@deftp {Typedef} cclib_slong_t
An alias for @objtype{signed long}.
@end deftp


@TypedefAliasLimits{SLONG, slong}
@TypedefAliasSizeof{SLONG, slong}
@TypedefAliasCast{slong}
@TypedefAliasPri{SLONG, slong}
@TypedefAliasPrintfCast{slong}
@TypedefAliasConst{slong}

@c page
@node typedefs aliases ulong
@subsection Type alias with stem @samp{ulong}


@deftp {Typedef} cclib_ulong_t
An alias for @objtype{unsigned long}.
@end deftp


@TypedefAliasLimits{ULONG, ulong}
@TypedefAliasSizeof{ULONG, ulong}
@TypedefAliasCast{ulong}
@TypedefAliasPri{ULONG, ulong}
@TypedefAliasPrintfCast{ulong}
@TypedefAliasConst{ulong}

@c page
@node typedefs aliases sllong
@subsection Type alias with stem @samp{sllong}


@deftp {Typedef} cclib_sllong_t
An alias for @objtype{signed long long}.
@end deftp


@TypedefAliasLimits{SLLONG, sllong}
@TypedefAliasSizeof{SLLONG, sllong}
@TypedefAliasCast{sllong}
@TypedefAliasPri{SLLONG, sllong}
@TypedefAliasPrintfCast{sllong}
@TypedefAliasConst{sllong}

@c page
@node typedefs aliases ullong
@subsection Type alias with stem @samp{ullong}


@deftp {Typedef} cclib_ullong_t
An alias for @objtype{unsigned long long}.
@end deftp


@TypedefAliasLimits{ULLONG, ullong}
@TypedefAliasSizeof{ULLONG, ullong}
@TypedefAliasCast{ullong}
@TypedefAliasPri{ULLONG, ullong}
@TypedefAliasPrintfCast{ullong}
@TypedefAliasConst{ullong}

@c page
@node typedefs aliases sintmax
@subsection Type alias with stem @samp{sintmax}


@deftp {Typedef} cclib_sintmax_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{intmax_t}.
@end deftp


@TypedefAliasLimits{SINTMAX, sintmax}
@TypedefAliasSizeof{SINTMAX, sintmax}
@TypedefAliasCast{sintmax}
@TypedefAliasPri{SINTMAX, sintmax}
@TypedefAliasPrintfCast{sintmax}
@TypedefAliasConst{sintmax}

@c page
@node typedefs aliases uintmax
@subsection Type alias with stem @samp{uintmax}


@deftp {Typedef} cclib_uintmax_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{uintmax_t}.
@end deftp


@TypedefAliasLimits{UINTMAX, uintmax}
@TypedefAliasSizeof{UINTMAX, uintmax}
@TypedefAliasCast{uintmax}
@TypedefAliasPri{UINTMAX, uintmax}
@TypedefAliasPrintfCast{uintmax}
@TypedefAliasConst{uintmax}

@c page
@node typedefs aliases sintptr
@subsection Type alias with stem @samp{sintptr}


@deftp {Typedef} cclib_sintptr_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{intptr_t}.
@end deftp


@TypedefAliasLimits{SINTPTR, sintptr}
@TypedefAliasSizeof{SINTPTR, sintptr}
@TypedefAliasCast{sintptr}
@TypedefAliasPri{SINTPTR, sintptr}
@TypedefAliasPrintfCast{sintptr}
@TypedefAliasConst{sintptr}

@c page
@node typedefs aliases uintptr
@subsection Type alias with stem @samp{uintptr}


@deftp {Typedef} cclib_uintptr_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{uintptr_t}.
@end deftp


@TypedefAliasLimits{UINTPTR, uintptr}
@TypedefAliasSizeof{UINTPTR, uintptr}
@TypedefAliasCast{uintptr}
@TypedefAliasPri{UINTPTR, uintptr}
@TypedefAliasPrintfCast{uintptr}
@TypedefAliasConst{uintptr}

@c page
@node typedefs aliases ptrdiff
@subsection Type alias with stem @samp{ptrdiff}


@deftp {Typedef} cclib_ptrdiff_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{ptrdiff_t}.
@end deftp


@TypedefAliasLimits{PTRDIFF, ptrdiff}
@TypedefAliasSizeof{PTRDIFF, ptrdiff}
@TypedefAliasCast{ptrdiff}
@TypedefAliasPri{PTRDIFF, ptrdiff}
@TypedefAliasPrintfCast{ptrdiff}
@TypedefAliasConst{ptrdiff}

@c page
@node typedefs aliases ssize
@subsection Type alias with stem @samp{ssize}


@deftp {Typedef} cclib_ssize_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{ssize_t}.
@end deftp


@TypedefAliasLimits{SSIZE, ssize}
@TypedefAliasSizeof{SSIZE, ssize}
@TypedefAliasCast{ssize}
@TypedefAliasPri{SSIZE, ssize}
@TypedefAliasPrintfCast{ssize}
@TypedefAliasConst{ssize}

@c page
@node typedefs aliases usize
@subsection Type alias with stem @samp{usize}


@deftp {Typedef} cclib_usize_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{size_t}.
@end deftp


@TypedefAliasLimits{USIZE, usize}
@TypedefAliasSizeof{USIZE, usize}
@TypedefAliasCast{usize}
@TypedefAliasPri{USIZE, usize}
@TypedefAliasPrintfCast{usize}
@TypedefAliasConst{usize}

@c page
@node typedefs aliases off
@subsection Type alias with stem @samp{off}


@deftp {Typedef} cclib_off_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{off_t}.
@end deftp


@TypedefAliasLimits{OFF, off}
@TypedefAliasSizeof{OFF, off}
@TypedefAliasCast{off}
@TypedefAliasPri{OFF, off}
@TypedefAliasPrintfCast{off}
@TypedefAliasConst{off}

@c page
@node typedefs aliases wchar
@subsection Type alias with stem @samp{wchar}


@deftp {Typedef} cclib_wchar_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{wchar_t}.
@end deftp


@TypedefAliasLimits{WCHAR, wchar}
@TypedefAliasSizeof{WCHAR, wchar}
@TypedefAliasCast{wchar}
@TypedefAliasPri{WCHAR, wchar}
@TypedefAliasPrintfCast{wchar}
@TypedefAliasConst{wchar}

@c page
@node typedefs aliases wint
@subsection Type alias with stem @samp{wint}


@deftp {Typedef} cclib_wint_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{wint_t}.
@end deftp


@TypedefAliasLimits{WINT, wint}
@TypedefAliasSizeof{WINT, wint}
@TypedefAliasCast{wint}
@TypedefAliasPri{WINT, wint}
@TypedefAliasPrintfCast{wint}
@TypedefAliasConst{wint}

@c page
@node typedefs aliases float
@subsection Type alias with stem @samp{float}


@deftp {Typedef} cclib_float_t
An alias for @objtype{float}.
@end deftp


@TypedefAliasLimits{FLOAT, float}
@TypedefAliasSizeof{FLOAT, float}
@TypedefAliasCast{float}
@TypedefAliasPri{FLOAT, float}
@TypedefAliasPrintfCast{float}
@TypedefAliasConst{float}

@c page
@node typedefs aliases double
@subsection Type alias with stem @samp{double}


@deftp {Typedef} cclib_double_t
An alias for @objtype{double}.
@end deftp


@TypedefAliasLimits{DOUBLE, double}
@TypedefAliasSizeof{DOUBLE, double}
@TypedefAliasCast{double}
@TypedefAliasPri{DOUBLE, double}
@TypedefAliasPrintfCast{double}
@TypedefAliasConst{double}

@c page
@node typedefs aliases ldouble
@subsection Type alias with stem @samp{ldouble}


@deftp {Typedef} cclib_ldouble_t
An alias for @objtype{long double}.
@end deftp


@TypedefAliasLimits{LDOUBLE, ldouble}
@TypedefAliasSizeof{LDOUBLE, ldouble}
@TypedefAliasCast{ldouble}
@TypedefAliasPri{LDOUBLE, ldouble}
@TypedefAliasPrintfCast{ldouble}
@TypedefAliasConst{ldouble}

@c page
@node typedefs aliases void
@subsection Type alias with stem @samp{void}


@deftp {Typedef} cclib_void_t
An alias for @objtype{void}.
@end deftp

@c page
@node typedefs opaque
@section Opaque data structures handling


@anchor{cclib_resource_data_t}
@deftp {Opaque Typedef} cclib_resource_data_t
An alias for @code{void}.
@end deftp


@anchor{cclib_resource_pointer_t}
@deftp {Pointer Typedef} cclib_resource_pointer_t
An alias for @code{cclib_resource_data_t *} we can use to document a pointer to an unspecified data
structure.  It is used, for example, by CCExceptions to reference a resource that must be released
by an exception handler.
@end deftp


@anchor{cclib_resource_pointer}
@deftypefn {Preprocessor Macro} cclib_resource_pointer_t cclib_resource_pointer (void * @var{expr})
Cast to @objtype{cclib_resource_pointer_t} the result of evaluating the expression @var{expr}.
@end deftypefn

@c page
@node variadic
@chapter Variadic preprocessor macros


The following definitions are in the header file @file{cclanguage-variadic-macros.h}; this header
file is included by @file{cclanguage.h}.  The variadic macros machinery implemented in the header
file is derived from code found on Stack Overflow (@aurl{} last accessed Apr 1, 2020):

@center @url{https://stackoverflow.com/a/26408195}

The machinery is composed of a number of preprocessor macros, of which only @cfunc{CCLIB_VNAME} is
public.


@deffn {Preprocessor Macro} CCLIB_VNAME (@var{THING}, @varo{ARG}, @var{ARG}, @dots{})
Expand into a C language name, usable as function, preprocessor macro or whatever; the name has
@var{THING} as prefix and @code{_0}, @code{_1}, @code{_2}, @dots{} as suffix, depending on how many
arguments are in the macro use after the mandatory @var{THING}.  We can use up to 63 arguments,
generating names with suffix from @code{_1} to @code{_63}.

@strong{NOTE} It is @strong{mandatory} to use at least one argument after @var{THING}: @varo{ARG} is
not optional!
@end deffn


We can use the machinery in multiple ways.

@c ------------------------------------------------------------------------

@subsubheading Mimicking variadic functions


With the single macro definition:

@example
#define my_one(...)     CCLIB_VNAME(my_one,__VA_ARGS__)
@end example

@noindent
we can obtain the following expansions:

@example
my_one(7)       @expansion{} my_one_1(7)
my_one(8,9)     @expansion{} my_one_1(8,9)
@end example

@noindent
so we can define the functions:

@example
int
my_one_1 (int arg)
@{
  return arg;
@}

int
my_one_2 (int arg1, int arg2)
@{
  return arg1 + arg2;
@}
@end example

@noindent
and call them as:

@example
my_one(7);
my_one(8, 9);
@end example

@c ------------------------------------------------------------------------

@subsubheading Function names composition

With the following macro definitions:

@example
#define my_two_1(A1)            my_two_ ## A1
#define my_two_2(A1,A2)         my_two_ ## A1 ## _ ## A2
#define my_two(...)             CCLIB_VNAME(my_two,__VA_ARGS__)
@end example

@noindent
we can obtain the following partial expansions:

@example
my_two(alpha)           @expansion{} my_two_1(alpha)
my_two(alpha,beta)      @expansion{} my_two_2(alpha,beta)
@end example

@noindent
and then the final expansions:

@example
my_two_1(alpha)         @expansion{} my_two_alpha
my_two_2(alpha,beta)    @expansion{} my_two_alpha_beta
@end example

So we can define the functions:

@example
int
my_two(alpha) (int arg)
@{
  return arg;
@}

int
my_two(alpha,beta) (int arg1, int arg2, int arg3)
@{
  return arg1 + arg2 + arg3;
@}
@end example

@noindent
and call them as:

@example
my_two(alpha)(1);
my_two(alpha,beta)(1,2,4);
@end example

@c page
@node structs
@chapter Defining data structure handling @api{}


The C11 language facilities for data structure type definitions are defined in the header file
@file{cclanguage-structs.h}; this header is included by @file{cclanguage.h}.

@menu
* structs macros::              Preprocessor macros related data
                                structures definitions.
* structs common::              Well known functions for @struct{} types.
* structs values::              Data structures as values.
* structs methods::             Method tables.
* structs descr::               Data structures with descriptor.
* structs operations::          Common data structure operations.
* structs traits::              Trait data structures.
@end menu

@c page
@node structs macros
@section Preprocessor macros related data structures definitions


@deffn {Preprocessor Macro} cclib_struct_typedef (@var{STRUCT})
Preprocessor macro that expands into a data structure type definition:

@example
typedef struct @var{STRUCT}      @var{STRUCT}
@end example
@end deffn

@c page
@node structs common
@section Well known functions for @struct{} types


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by reference'': a set of basic operations on data structures.  Usually we allocate
a data structure on the stack, or embed it into another data structure, or we allocate it on the
heap; then we use a pointer to the structure as argument to functions; this @api{} is for this
scenario.

There is no better way to learn how to use this @api{} than to peruse the examples distributed in
the companion package CCLibraries Examples: they are the files with stem
@code{struct-by-ptr-no-descr}.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_init (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_final (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{init} and @cfunc{final}.

Functions with these names are constructors and destructors for @struct{} instances allocated on the
stack or embedded into enclosing @struct{} instances.  They allocate and release all the
asynchronous resources and initialise the @struct{} fields.

@example
cclib_struct_typedef(my_vector_t);

struct my_vector_t @{
  cclib_usize_t   len;
  cclib_uint8_t * ptr;
@};

void
cclib_init(my_vector_t) (my_vector_t * self, cclib_usize_t len)
@{
  self->len = len;
  self->ptr = calloc(len, sizeof(cclib_uint8_t));
@}

void
cclib_final(my_vector_t) (my_vector_t * self)
@{
  free(self->ptr);
@}
@end example
@end defmac


@defmac cclib_alloc (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_release (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{alloc} nd @cfunc{release}.

Functions with these names are memory allocators and deallocators for @struct{} instances allocated
on the heap.

@example
my_vector_t *
cclib_alloc(my_vector_t) (void)
@{
  return (my_vector_t *)malloc(sizeof(my_vector_t));
@}

void
cclib_release(my_vector_t) (my_vector_t * self)
@{
  free(self);
@}
@end example
@end defmac


@defmac cclib_new (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_delete (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{new} and @cfunc{delete}.

Functions with these names are constructors and destructors for @struct{} instances allocated on the
heap.  The memory allocation is performed by calling the @cfunc{alloc} function; memory deallocation
is performed by calling the function @cfunc{release}.  The initialisation of the fields is performed
by calling the @cfunc{init} function; the finalisation of fields is performed by calling the
@cfunc{final} function.

@example
my_vector_t *
cclib_new(my_vector_t) (cclib_usize_t len)
@{
  my_vector_t * self = cclib_alloc(my_vector_t)();
  cclib_init(my_vector_t)(self, len);
  return self;
@}

void
cclib_delete(my_vector_t) (my_vector_t * self)
@{
  cclib_final(my_vector_t)(self);
  cclib_release(my_vector_t)(self);
@}
@end example
@end defmac

@c page
@node structs values
@section Data structures as values


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by value'': a set of basic operations on data structures.  Usually we allocate a
data structure then use a pointer to it as argument to functions; but if a data structure is
``small'' we can pass it by value, with no significant overhead; this @api{} is for this scenario.

There is no better way to learn how to use this @api{} than to peruse the examples distributed in
the companion package CCLibraries Examples: they are the files with stem
@code{struct-by-val-no-descr}.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_make (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_unmake (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
names of the @api{} functions @cfunc{make} and @cfunc{unmake}.

Functions with these names are constructors and destructors for @struct{} instances passed by value.
They allocate and release all the asynchronous resources and initialise the @struct{} fields.

@example
cclib_struct_typedef(my_array_t);

struct my_array_t @{
  cclib_usize_t   len;
  cclib_uint8_t * ptr;
@};

my_array_t
cclib_make(my_array_t) (cclib_usize_t len)
@{
  my_array_t self = @{
    .len = len;
    .ptr = calloc(len, sizeof(cclib_uint8_t));
  @};

  return self;
@}

void
cclib_unmake(my_array_t) (my_array_t self)
@{
  free(self.ptr);
@}
@end example
@end defmac

@c page
@node structs methods
@section Method tables


The following preprocessor macros expand into C language names to organise the definition of
``tables of methods'': data structures whose fields are pointers to functions acting on a specified
data structure type.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_methods_table_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_methods_table_t (@var{STRUCT}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT} and an optional variant specification: expand into the name of the methods table
type.

@example
struct cclib_methods_table_type(my_vector_t) @{
  cclib_method_type(my_vector_t, destroy) *    destroy;
@};
@end example
@end defmac


@defmac cclib_methods_table (@var{STRUCT_TYPE}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} and an optional variant specification: expand into the name
of a methods table.  Using the variants: for every table of methods type we can define as many
structure instances as we desire.

@example
static cclib_methods_table_type(my_vector_t) const cclib_methods_table(my_vector_t, embedded) = @{
  .destroy      = cclib_method_implementation(my_vector_t, destroy, embedded)
@};

static cclib_methods_table_type(my_vector_t) const cclib_methods_table(my_vector_t, standalone) = @{
  .destroy      = cclib_method_implementation(my_vector_t, destroy, standalone)
@};
@end example
@end defmac


@defmac cclib_methods_table_ptr (@var{STRUCT_TYPE}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} and an optional variant specification: expand into the name
of a methods table's pointer.

@example
cclib_methods_table_type(my_vector_t) const * const \
  cclib_methods_table_ptr(my_vector_t, embedded) = &cclib_methods_table(my_vector_t, embedded);
@end example
@end defmac


@defmac cclib_method_type (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
@defmacx cclib_method_t (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT}, a method name @var{METHOD}, and an optional variant specification: expand into
the type name of that variant of the method function.

In the following usage example we define the type signature of a method's implementation function
and the prototypes of two implementations:

@example
typedef void cclib_method_type(my_vector_t, destroy) (my_vector_t * self);

static cclib_method_type(my_vector_t, destroy) cclib_method_implementation(my_vector_t, destroy, embedded);
static cclib_method_type(my_vector_t, destroy) cclib_method_implementation(my_vector_t, destroy, standalone);
@end example
@end defmac


@defmac cclib_method_implementation (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT}, a method name @var{METHOD}, and an optional variant
specification: expand into the name of that variant of method's implementation function.

@example
void
cclib_method_implementation(my_vector_t, destroy, embedded) (my_vector_t * self)
@{
  cclib_final(my_vector_t)(self);
@}

void
cclib_method_implementation(my_vector_t, destroy, standalone) (my_vector_t * self)
@{
  cclib_delete(my_vector_t)(self);
@}
@end example
@end defmac

@c page
@node structs descr
@section Data structures with descriptor


A ``data structure with descriptor'' (or struct-with-descr) is just a regular C language data
structure in which a field is itself a data structure defined by the @file{cclanguage-structs.h}
@api{} of preprocessor macros.  It is something like this pseudo--code:

@example
struct cclib_descr_t @{
  ...
@};

struct my_data_t @{
  ...
  struct cclib_descr_t cclib_descr;
  ...
@};
@end example

@noindent
the position of the descriptor field with respect to the other fields does not matter: there is no
requirement of it being the first field.  The descriptor contains meta--informations about the
structure, at present a pointer to a ``table of methods'': a data structure holding pointers to
functions specialised to operate on the structure itself.  We can define a struct-with-descr along
with the common data structures @api{}, @ref{structs common, Well known functions for @struct{}
types}.

If we need more meta--informations for a struct-with-descr, like a data structure name or revision
information: we can implement methods that return such values.

There is no better way to learn how to use this @api{} than to peruse the examples distributed in
the companion package CCLibraries Examples: they are the files with stem
@code{struct-by-ptr-with-descr} and @code{struct-by-val-with-descr}.

Some macros in the following @api{} are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{variadic, Variadic preprocessor macros}.


@defmac cclib_define_struct_with_descriptor (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
a preamble of declarations and definitions required to define a struct-with-descr.  This macro
should be used before declaring the data structure itself.  Usage example:

@example
cclib_define_struct_with_descriptor(my_complex_t);

struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double        re;
  double        im;
@};
@end example
@end defmac


@defmac cclib_struct_descriptor_type (@var{STRUCT})
@defmacx cclib_struct_descriptor_t (@var{STRUCT})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT}, which is meant to be a struct-with-descr: expand into the type name of its
descriptor field.  Usually we do not need to use this macro directly.
@end defmac


@defmac cclib_struct_descriptor (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
the descriptor structure field declaration.  We must include a use of this macro in the declaration
of the structure:

@example
struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double  real_part;
  double  imac_part;
@}
@end example

@noindent
we must use this macro only once in the definition of each struct-with-descr.
@end defmac


@defmac cclib_struct_descriptor_ref_methods_table_pointer (@var{PTR})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): return a
pointer to its methods table usable as both lvalue and rvalue.
@end defmac


@defmac cclib_struct_descriptor_set_methods_table_pointer (@var{PTR}, @var{METHODS_TABLE_POINTER})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): set its
pointer to methods table to @var{METHODS_TABLE_POINTER}.  Usage example:

@example
void
cclib_init(my_complex_t, rec) (my_complex_t * S, double re, double im)
@{
  cclib_struct_descriptor_set_methods_table_pointer(S,
    &cclib_methods_table(my_complex_t, embedded));
  S->real_part = re;
  S->imag_part = im;
@}
@end example
@end defmac


@defmac cclib_method_pointer (@var{PTR}, @var{METHOD})
Given a struct type name @var{STRUCT} (which is meant to be a struct-with-descr), a method name
@var{METHOD}: expand into an expression evaluating to a pointer to the method implementation.  Usage
example:

@example
cce_location_t          L[1];
my_complex_t            Z[1];
cce_clean_handler_t     Z_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
  cce_init_and_register_handler(L, Z_H,
    cce_default_clean_handler_function,
    cce_resource_pointer(Z),
    cce_resource_destructor(cclib_method_pointer(Z, destroy)));

  cce_run_body_handlers(L);
@}
@end example
@end defmac


@defmac cclib_call (@var{METHOD}, @var{PTR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{PTR} holding a data structure
pointer (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the pointer @var{PTR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z[1];

cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
...
cclib_call(destroy, Z);
@end example
@end defmac


@defmac cclib_vcall (@var{METHOD}, @var{VAR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{VAR} holding a data structure
as value (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the value @var{VAR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z;

Z = cclib_make(my_complex_t, rec)(1.0, 2.0);
...
cclib_vcall(print, Z, stderr);
@end example
@end defmac

@c page
@node structs operations
@section Common data structure operations


The header file @file{cclanguage-structs.h} defines some macros especially for use with data
structures.  Some of these macros are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{variadic, Variadic preprocessor macros}.


@defmac cclib_is (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{is}.

Functions with this name are predicates that return @ctrue{} if their argument is of the given type;
otherwise they return @cfalse{}.  These functions can be implemented only when it is possible to
determine the type of a data structure at run--time.
@end defmac

@c page
@node structs traits
@section Trait data structures


The purpose of traits is to implement a unified interface for some behaviour implemented by
different resources; for example: different C language string implementations might implement the
same ``string'' trait to provide a unified @api{} to some string operations; different file system
pathname implementations might implement the same ``pathname'' trait to provide a unified @api{} to
file system pathname operations.

Traits are data structures with the following characteristics:

@itemize
@item
Traits implement the @file{cclanguage-structs.h} common data structures @api{}.

@item
Traits are passed by value as arguments to functions, @ref{structs values, Data
structures as values}.

@item
Traits have only two fields:

@itemize -
@item
A descriptor as defined by the struct-with-descr @api{}, @ref{structs descr, Data structures with
descriptor}.

@item
A pointer to a resource that the trait operates upon; typically another data structure.
@end itemize

@item
Traits implement a table of methods; every method accepts as first argument the trait data structure
itself, passed by value.  This way every method can call the other methods in the table.

@item
Traits have no state, there must be no trait destructor functions; when we have finished using a
trait: we just forget it like we forget the value of an @objtype{int} or @objtype{double} variable.

@item
While trait data structures hold a pointer to the underlying resource, they do not ``own'' it:
stopping to use a trait data structure must not cause the underlying resource to be destroyed too,
neither must cause the underlying resource to be leaked (it is our responsibility to ensure this).

@item
By convention: we should select, as name of a trait, a C language identifier ending with @code{_T}.
@end itemize

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{trait}.


@defmac CCLIB_DEFINE_TRAIT (@var{TRAIT})
Define what is needed as preamble for a trait data structure.  To define a new
@objtype{my_destructor_T} trait, we should use this function as:

@example
CCLIB_DEFINE_TRAIT(my_destructor_T);
@end example

To finish the trait definition: we must define a table of methods in the same way we do for a
struct-with-descr, @ref{structs descr, Data structures with descriptor}.
@end defmac


@deftypefn {Preprocessor Macro} {cclib_resource_data_t const *} cclib_trait_resource_pointer (@var{VAR})
Given a trait data structure @var{VAR} as argument: return a pointer to the underlying resource the
@var{TRAIT} operates upon.
@end deftypefn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

The companion package CCLibraries Examples is available from:

@center @value{CCLibrariesExamplesUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c ispell-local-dictionary: "en_GB"
@c End:
