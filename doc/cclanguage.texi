\input texinfo.tex
@c %**start of header
@setfilename cclanguage.info
@settitle CCLanguage
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Document specific macros.
@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cclanguage

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @file{cclibraries.h}, a C11 Standard language
header file; it implements basic definitions used by all the packages in the CCLibraries project.

The code is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cclibraries: (cclibraries).       CCLibraries, C11 language core header file.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* requisites::                  Requirements.
* attributes::                  Compiler attributes for functions.
* declarations::                Functions and variables visibility declarations.
* macros::                      Helper macros.
* typedefs::                    Common type definitions and related macros.
* variadic::                    Variadic preprocessor macros.
* structs::                     Defining data structure handling @api{}.
* exceptions::                  Exception handling helpers.
* conditions::                  Exceptional-condition objects.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @file{cclibraries.h}, a C11 Standard language
header file; it implements basic definitions used by all the projects in the CCLibraries.

The header file @file{cclibraries.h} is meant to be included in the source files of all the
CCLibraries projects; it is included by @file{ccexceptions.h}; it is distributed with the
CCExceptions project because CCExceptions implements core facilities for all the CCLibraries
packages.

The header file @file{cclibraries.h} is meant to support the C11 language standard on @posix{}
platforms.  All the macro definitions are prefixed with @code{CCLIB_} or @code{cclib_}; all the type
names are prefixed with @code{cclib_} and suffixed with @code{_t}.

@c page
@node requisites
@chapter Requirements


The header file @file{cclibraries.h} expects to be compiled in an environment set up by @gnu{}
Autoconf; there must be a project--specific @file{config.h} file that @file{cclibraries.h} will
include as:

@example
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
@end example

@noindent
and the template configuration script @file{configure.ac} must call the macro:

@example
CCLIB_CONFIG_SETUP()
@end example

@noindent
so the package distribution must include all the required @gnu{} Autoconf macro files and load them
correctly.

@c page
@node attributes
@chapter Compiler attributes for functions


The following definitions are in the header file @file{cclibraries.h}.  The header file tries to
determine, through the C preprocessor macros, which function attributes are implemented by the
compiler and defines the following macros accordingly.  If an attribute is not implemented: the
corresponding macro is defined to expand to the empty string.

A typical function prototype declaration for a function using the facilities of @value{PACKAGE}
looks like this:

@example
cclib_decl void * cce_sys_malloc (cce_destination_t L, size_t size)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
  CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
  CCLIB_FUNC_ATTRIBUTE_LEAF;
@end example

@noindent
while a @code{static} and @code{inline} function definition looks like this:

@example
CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
CCLIB_FUNC_ATTRIBUTE_PURE
CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
static inline cce_handler_t *
cce_clean_handler_handler (cce_clean_handler_t * const H)
@{
  ...
@}
@end example


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
Expand into:

@example
__attribute__((__always_inline__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONST
Expand into:

@example
__attribute__((__const__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONSTRUCTOR
Expand into:

@example
__attribute__((__constructor__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLEXPORT
Expand into:

@example
__attribute__((__dllexport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLIMPORT
Expand into:

@example
__attribute__((__dllimport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_FORMAT (...)
Expand into:

@example
__attribute__((__format__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_HOT
Expand into:

@example
__attribute__((__hot__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_LEAF
Expand into:

@example
__attribute__((__leaf__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NONNULL (...)
Expand into:

@example
__attribute__((__nonnull__(__VA_ARGS__)))
@end example

We can use this macro as follows:

@example
cclib_decl void my_func (int * dst, int * src)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1,2);
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NORETURN
Expand into:

@example
__attribute__((__noreturn__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_PURE
Expand into:

@example
__attribute__((__pure__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
Expand into:

@example
__attribute__((__returns_nonnull__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_UNUSED
Expand into:

@example
__attribute__((__unused__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_USED
Expand into:

@example
__attribute__((__used__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_VISIBILITY (...)
Expand into:

@example
__attribute__((__visibility__(__VA_ARGS__)))
@end example
@end deffn

@c page
@node declarations
@chapter Functions and variables visibility declarations


The following definitions are in the header file @file{cclibraries.h}.


@deffn {Preprocessor Macro} cclib_decl
Expand into the qualifiers for a public @api{} declaration.  When using the @gnu{} C Compiler on a
@posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("default") extern
@end example
@end deffn


@deffn {Preprocessor Macro} cclib_private_decl
Expand into the qualifiers for a private @api{} declaration: entities qualified with this macro are
meant to be visible only inside the namespace of a shared library.  When using the @gnu{} C Compiler
on a @posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("hidden")  extern
@end example
@end deffn

@c page
@node macros
@chapter Helper macros


The following definitions are in the header file @file{cclibraries.h}.


@deffn {Preprocessor Macro} CCLIB_CAST (@var{TYPE}, @var{X}, @var{Y})
Type cast helper.  It expands into:

@example
@var{TYPE} @var{X} = (@var{TYPE}) (@var{Y})
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
ccevents_timeval_invalid_t * K = (ccevents_timeval_invalid_t *) C;
@end example

@noindent
we can write:

@example
cce_location_t    L[1];
cce_condition_t * C = cce_condition(L);
CCLIB_PC(ccevents_timeval_invalid_t, K, C);
@end example

@noindent
or:

@example
cce_location_t    L[1];
CCLIB_PC(ccevents_timeval_invalid_t, C, cce_condition(L));
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  It expands into:

@example
CCLIB_FUNC_ATTRIBUTE_UNUSED
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_STRUCT_TYPEDEF (@var{STRUCT})
Preprocessor macro that expands into a data structure typedef:

@example
typedef struct @var{STRUCT}      @var{STRUCT}
@end example
@end deffn

@c page
@node typedefs
@chapter Common type definitions and related macros


@menu
* typedefs opaque::             Opaque data structures handling.
@end menu

@c page
@node typedefs opaque
@section Opaque data structures handling


@anchor{cclib_resource_data_t}
@deftp {Opaque Typedef} cclib_resource_data_t
An alias for @code{void}.
@end deftp


@anchor{cclib_resource_pointer_t}
@deftp {Pointer Typedef} cclib_resource_pointer_t
An alias for @code{cclib_resource_data_t *} we can use to document a pointer to an unspecified data
structure.  It is used, for example, by CCExceptions to reference a resource that must be released
by an exception handler.
@end deftp


@anchor{cclib_resource_pointer}
@deftypefn {Preprocessor Macro} cclib_resource_pointer_t cclib_resource_pointer (void * @var{expr})
Cast to @objtype{cclib_resource_pointer_t} the result of evaluating the expression @var{expr}.
@end deftypefn

@c page
@node variadic
@chapter Variadic preprocessor macros


The following definitions are in the header file @file{cclibraries.h}.  The variadic macros
machinery implemented in the header file is derived from code found on Stack Overflow (@aurl{} last
accessed Apr 1, 2020):

@center @url{https://stackoverflow.com/a/26408195}

The machinery is composed of a number of preprocessor macros, of which only @cfunc{CCLIB_VNAME} is
public.


@deffn {Preprocessor Macro} CCLIB_VNAME (@var{FUNC}, @var{ARG}, ...)
Expand into the name of a C language function or preprocessor macro; the name has @var{FUNC} as
prefix and @code{_0}, @code{_1}, @code{_2}, @dots{} as suffix, depending on how many arguments are
in the macro use after the mandatory @var{FUNC}.  We can use up to 63 arguments, generating names
with suffix from @code{_1} to @code{_63}.

@strong{NOTE} It is @strong{mandatory} to use at least one argument after @var{FUNC}: @var{ARG} is
not optional!
@end deffn


We can use the machinery in multiple ways.

@c ------------------------------------------------------------------------

@subsubheading Mimicking variadic functions


With the single macro definition:

@example
#define my_one(...)     CCLIB_VNAME(my_one,__VA_ARGS__)
@end example

@noindent
we can obtain the following expansions:

@example
my_one(7)       @expansion{} my_one_1(7)
my_one(8,9)     @expansion{} my_one_1(8,9)
@end example

@noindent
so we can define the functions:

@example
int
my_one_1 (int arg)
@{
  return arg;
@}

int
my_one_2 (int arg1, int arg2)
@{
  return arg1 + arg2;
@}
@end example

@noindent
and call them as:

@example
my_one(7);
my_one(8, 9);
@end example

@c ------------------------------------------------------------------------

@subsubheading Function names composition

With the following macro definitions:

@example
#define my_two_1(A1)            my_two_ ## A1
#define my_two_2(A1,A2)         my_two_ ## A1 ## _ ## A2
#define my_two(...)             CCLIB_VNAME(my_two,__VA_ARGS__)
@end example

@noindent
we can obtain the following partial expansions:

@example
my_two(alpha)           @expansion{} my_two_1(alpha)
my_two(alpha,beta)      @expansion{} my_two_2(alpha,beta)
@end example

@noindent
and then the final expansions:

@example
my_two_1(alpha)         @expansion{} my_two_alpha
my_two_2(alpha,beta)    @expansion{} my_two_alpha_beta
@end example

So we can define the functions:

@example
int
my_two(alpha) (int arg)
@{
  return arg;
@}

int
my_two(alpha,beta) (int arg1, int arg2, int arg3)
@{
  return arg1 + arg2 + arg3;
@}
@end example

@noindent
and call them as:

@example
my_two(alpha)(1);
my_two(alpha,beta)(1,2,4);
@end example

@c page
@node structs
@chapter Defining data structure handling @api{}


@menu
* structs common::              Well known functions for @struct{} types.
* structs values::              Data structures as values.
* structs descr::               Data structures with descriptor.
* structs traits::              Trait data structures.
@end menu

@c page
@node structs common
@section Well known functions for @struct{} types


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by reference'': a set of basic operations on data structures.  Usually we allocate
a data structure on the stack, or embed it into another data structure, or we allocate it on the
heap, then we use a pointer to the structure as argument to functions; this @api{} is for this
scenario.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-by-ptr-no-descr}.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_init (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac cclib_final (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac cclib_alloc (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.
@end defmac


@defmac cclib_release (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.
@end defmac


@defmac cclib_new (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac cclib_delete (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


@defmac cclib_is (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{is}.

Functions with this name are predicates that return @ctrue{} if their argument is of the given type;
otherwise they return @cfalse{}.  These functions can be implemented only when it is possible to
determine the type of a data structure at run--time.
@end defmac


The following code is a usage example of common function implementation for @struct{} types; this
example is distributed in source form under the directory @file{examples} of CCExceptions, with the
file stem @code{struct-by-ptr-no-descr}.

@smallexample
#include <ccexceptions.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef my_coords_t     my_coords_t;

struct my_coords_t @{
  double  X;
  double  Y;
@};

void
cclib_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
cclib_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
cclib_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
cclib_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)cce_sys_malloc(L, sizeof(my_coords_t));
@}

static void
cclib_release(my_coords_t) (my_coords_t * S)
@{
  free(S);
@}

my_coords_t *
cclib_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = cclib_alloc(my_coords_t)(L);

  cclib_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
cclib_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = cclib_alloc(my_coords_t)(L);

  cclib_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
cclib_delete(my_coords_t) (my_coords_t * S)
@{
  cclib_final(my_coords_t)(S);
  cclib_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  cce_clean_handler_t   S_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = cclib_new(my_coords_t, rec)(L, 1.0, 2.0);
    cce_init_and_register_handler(L, S_H,
      cce_default_clean_handler_function,
      cce_resource_pointer(S),
      cce_resource_destructor(cclib_delete(my_coords_t)));

    printf("X=%f, Y=%f\n", S->X, S->Y);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node structs values
@section Data structures as values


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by value'': a set of basic operations on data structures.  Usually we allocate a
data structure then use a pointer to it as argument to functions; but if a data structure is
``small'' we can pass it by value, with no significant overhead; this @api{} is for this scenario.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-by-val-no-descr}.

The header file @file{cclibraries.h} defines some macros especially for use with structures as
values.  Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_make (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
name of the @api{} function @cfunc{make}.  Functions with this name are constructors for @struct{}
instances passed by value.  Usage example:

@example
typedef struct my_complex_t     my_complex_t;

struct my_complex_t @{
  double  real_part;
  double  imag_part;
@};

my_complex_t
cclib_make(my_complex_t) (double re, double im)
@{
  my_complex_t Z = @{
    .real_part = re,
    .imag_part = im
  @};

  return Z;
@}
@end example
@end defmac


@defmac cclib_unmake (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
name of the @api{} function @cfunc{unmake}.  Functions with this name are destructors for @struct{}
instances passed by value.
@end defmac

@c page
@node structs descr
@section Data structures with descriptor


A ``data structure with descriptor'' (or struct-with-descr) is just a regular C language data
structure in which a field is itself a data structure defined by the @file{cclibraries.h} @api{} of
preprocessor macros.  It is something like this pseudo--code:

@example
struct cclib_descr_t @{
  ...
@};

struct my_data_t @{
  ...
  struct cclib_descr_t cclib_descr;
  ...
@};
@end example

@noindent
the position of the descriptor field with respect to the other fields does not matter: there is no
requirement of it being the first field.  The descriptor contains meta--informations about the
structure, at present a pointer to a ``table of methods'': a data structure holding pointers to
functions specialised to operate on the structure itself.  We can define a struct-with-descr along
with the common data structures @api{}, @ref{structs common, Well known functions for @struct{}
types}.

If we need more meta--informations for a struct-with-descr, like a data structure name or revision
information: we can implement methods that return such values.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-by-ptr-with-descr} and
@code{struct-by-val-with-descr}.

Some macros in the following @api{} are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{variadic, Variadic preprocessor macros}.


@defmac CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
a preamble of declarations and definitions required to define a struct-with-descr.  This macro
should be used before declaring the data structure itself.  Usage example:

@example
CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR(my_complex_t);

struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double        re;
  double        im;
@};
@end example
@end defmac


@defmac cclib_struct_descriptor_type (@var{STRUCT})
@defmacx cclib_struct_descriptor_t (@var{STRUCT})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT}, which is meant to be a struct-with-descr: expand into the type name of its
descriptor field.  Usually we do not need to use this macro directly.
@end defmac


@defmac cclib_struct_descriptor (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
the descriptor structure field declaration.  We must include a use of this macro in the declaration
of the structure:

@example
struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double  real_part;
  double  imac_part;
@}
@end example

@noindent
we must use this macro only once in the definition of each struct-with-descr.
@end defmac


@defmac cclib_methods_table_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_methods_table_t (@var{STRUCT}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT} (which is meant to be a struct-with-descr) and an optional variant
specification: expand into the name of the methods table type.  For every struct-with-descr we
can define a single table of methods.  Usage example:

@example
struct cclib_methods_table_type(my_complex_t) @{
  cclib_method_type(my_complex_t, destroy) *    destroy;
@};
@end example
@end defmac


@defmac cclib_methods_table (@var{STRUCT_TYPE}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a struct-with-descr) and an
optional variant specification: expand into the name of the methods table for the @struct{} type.
For every table of methods type we can define as many structure instances as we desire.  Usage
example:

@example
static cclib_methods_table_type(my_complex_t) const
    cclib_methods_table(my_complex_t, embedded) = @{
  .destroy      = cclib_method(my_complex_t, destroy, embedded)
@};

static cclib_methods_table_type(my_complex_t) const
    cclib_methods_table(my_complex_t, standalone) = @{
  .destroy      = cclib_method(my_complex_t, destroy, standalone)
@};
@end example
@end defmac


@defmac cclib_method_type (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
@defmacx cclib_method_t (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT} (which is meant to be a struct-with-descr), a method name @var{METHOD}, and an
optional variant specification: expand into the type name of that variant of the method function.

Usage example to define the type signature of a method's implementation function and its prototype:

@example
typedef void cclib_method_type(my_complex_t, destroy) (my_complex_t * self);

static cclib_method_type(my_complex_t, destroy) cclib_method(my_complex_t, destroy);
@end example
@end defmac


@defmac cclib_method (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} (which is meant to be a struct-with-descr), a method
name @var{METHOD}, and an optional variant specification: expand into the name of that variant of
method's implementation function.  Usage example to define a couple of method implementations:

@example
void
cclib_method(my_complex_t, destroy, embedded) (my_complex_t * self)
@{
  cclib_final(my_complex_t)(self);
@}

void
cclib_method(my_complex_t, destroy, standalone) (my_complex_t * self)
@{
  cclib_delete(my_complex_t)(self);
@}
@end example
@end defmac


@defmac cclib_struct_descriptor_ref_methods_table_pointer (@var{PTR})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): return a
pointer to its methods table usable as both lvalue and rvalue.
@end defmac


@defmac cclib_struct_descriptor_set_methods_table_pointer (@var{PTR}, @var{METHODS_TABLE_POINTER})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): set its
pointer to methods table to @var{METHODS_TABLE_POINTER}.  Usage example:

@example
void
cclib_init(my_complex_t, rec) (my_complex_t * S, double re, double im)
@{
  cclib_struct_descriptor_set_methods_table_pointer(S,
    &cclib_methods_table(my_complex_t, embedded));
  S->real_part = re;
  S->imag_part = im;
@}
@end example
@end defmac


@defmac cclib_method_pointer (@var{PTR}, @var{METHOD})
Given a struct type name @var{STRUCT} (which is meant to be a struct-with-descr), a method name
@var{METHOD}: expand into an expression evaluating to a pointer to the method implementation.  Usage
example:

@example
cce_location_t          L[1];
my_complex_t            Z[1];
cce_clean_handler_t     Z_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
  cce_init_and_register_handler(L, Z_H,
    cce_default_clean_handler_function,
    cce_resource_pointer(Z),
    cce_resource_destructor(cclib_method_pointer(Z, destroy)));

  cce_run_body_handlers(L);
@}
@end example
@end defmac


@defmac cclib_call (@var{METHOD}, @var{PTR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{PTR} holding a data structure
pointer (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the pointer @var{PTR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z[1];

cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
...
cclib_call(destroy, Z);
@end example
@end defmac


@defmac cclib_vcall (@var{METHOD}, @var{VAR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{VAR} holding a data structure
as value (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the value @var{VAR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z;

Z = cclib_make(my_complex_t, rec)(1.0, 2.0);
...
cclib_vcall(print, Z, stderr);
@end example
@end defmac

@c page
@node structs traits
@section Trait data structures


The purpose of traits is to implement a unified interface for some behaviour implemented by
different resources; for example: different C language string implementations might implement the
same ``string'' trait to provide a unified @api{} to some string operations; different file system
pathname implementations might implement the same ``pathname'' trait to provide a unified @api{} to
file system pathname operations.

Traits are data structures with the following characteristics:

@itemize
@item
Traits implement the @file{cclibraries.h} common data structures @api{}.

@item
Traits are passed by value as arguments to functions, @ref{structs values, Data
structures as values}.

@item
Traits have only two fields:

@itemize -
@item
A descriptor as defined by the struct-with-descr @api{}, @ref{structs descr, Data structures with
descriptor}.

@item
A pointer to a resource that the trait operates upon; typically another data structure.
@end itemize

@item
Traits implement a table of methods; every method accepts as first argument the trait data structure
itself, passed by value.  This way every method can call the other methods in the table.

@item
Traits have no state, there must be no trait destructor functions; when we have finished using a
trait: we just forget it like we forget the value of an @objtype{int} or @objtype{double} variable.

@item
While trait data structures hold a pointer to the underlying resource, they do not ``own'' it:
stopping to use a trait data structure must not cause the underlying resource to be destroyed too,
neither must cause the underlying resource to be leaked (it is our responsibility to ensure this).

@item
By convention: we should select, as name of a trait, a C language identifier ending with @code{_T}.
@end itemize

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{trait}.


@defmac CCLIB_DEFINE_TRAIT (@var{TRAIT})
Define what is needed as preamble for a trait data structure.  To define a new
@objtype{my_destructor_T} trait, we should use this function as:

@example
CCLIB_DEFINE_TRAIT(my_destructor_T);
@end example

To finish the trait definition: we must define a table of methods in the same way we do for a
struct-with-descr, @ref{structs descr, Data structures with descriptor}.
@end defmac


@deftypefn {Preprocessor Macro} {cclib_resource_data_t const *} cclib_trait_resource_pointer (@var{VAR})
Given a trait data structure @var{VAR} as argument: return a pointer to the underlying resource the
@var{TRAIT} operates upon.
@end deftypefn

@c page
@node exceptions
@chapter Exception handling helpers


The location handlers @api{} defined by CCExceptions requires data types and functions with specific
roles, @ccexceptionsref{handlers, The location handlers @api{}}.  The header file
@file{cclibraries.h} defines some preprocessor macros to tag the names of such definitions with
their intended purpose.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples; all the examples defining a data structure type also implement the associated
exception--handlers.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_exception_handler_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_exception_handler_t (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of an exception--handler structure to be used to finalise instances of the structure
type.  The data structure types should be wrappers for @objtype{cce_clean_handler_t} and
@objtype{cce_error_handler_t}.
@end defmac


@defmac cclib_exception_handler_function (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of a function to be used as exception--handler.  These functions should have the type
signature defined by the types @objtype{cce_clean_handler_fun_t} and
@objtype{cce_error_handler_fun_t}.
@end defmac


@defmac cclib_exception_handler_init_and_register (@var{STRUCT}, @var{VARIANT}, @dots{})
Given the name of a data structure type @var{STRUCT}, and an optional variant specification: expand
into the name of a function to be used to initialise an exception handler to finalise an instance of
the structure type.  These functions should call @cfunc{cce_init_and_register_handler} to perform
the operation.
@end defmac

@c page
@node conditions
@chapter Exceptional--condition objects


The exceptional--condition objects @api{} defined by CCExceptions requires data types and functions
with specific roles, @ccexceptionsref{conditions, Exceptional condition descriptors}.  The header
file @file{cclibraries.h} defines some preprocessor macros to tag the names of such definitions with
their intended purpose.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{condition-object}.

All the macros are variadic and accept from zero up to three @var{VARIANT} arguments; @ref{variadic,
Variadic preprocessor macros}.  The @var{STEM} argument to a macro must uniquely identify an
exceptional--condition object type; it should be composed by:

@itemize
@item
A library or context prefix, like @code{cce_} for CCExceptions types.

@item
An exceptional--condition description, like @code{logic_error}.
@end itemize


@defmac cclib_exceptional_condition_descriptor_type (@var{STEM}, @var{VARIANT}, @dots{})
@defmacx cclib_exceptional_condition_descriptor_t (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition descriptor type.  Usage example:

@example
struct cclib_exceptional_condition_descriptor_type(my_error) @{
  cce_descriptor_t      descriptor;
@};
@end example
@end defmac


@defmac cclib_exceptional_condition_descriptor (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition descriptor variable.  Usage example:

@example
static cclib_exceptional_condition_descriptor_type(my_error)
    cclib_exceptional_condition_descriptor(my_error) = @{
  .descriptor.parent            = ...,
  .descriptor.final             = ...,
  .descriptor.delete            = ...,
  .descriptor.static_message    = ...
@};
@end example
@end defmac


@deftypefn {Preprocessor Macro} {cce_descriptor_t *} cclib_exceptional_condition_descriptor_pointer (@var{STEM}, @var{VARIANT}, @dots{})
This macro is similar to @cfunc{cce_descriptor_pointer}, @ccexceptionsref{conditions descriptors,
cce_descriptor_pointer}.  Expand into an expression evaluating to the pointer to an
exceptional--condition descriptor variable.  The expression:

@example
cclib_exceptional_condition_descriptor_pointer(my_error)
@end example

@noindent
expands into the address of the field @code{descriptor} in the data structure variable:

@example
cclib_exceptional_condition_descriptor(my_error)
@end example
@end deftypefn


@defmac cclib_exceptional_condition_descriptor_set_parent_to (@var{STEM}, @var{VARIANT}, @dots{})
This macro is similar to @cfunc{cce_descriptor_set_parent_to}, @ccexceptionsref{conditions
descriptors, cce_descriptor_set_parent_to}.  Expand into the name of a function that set the parent
of a descriptor.  Usage example:

@example
void
cclib_exceptional_condition_descriptor_set_parent_to(my_error) (cce_descriptor_t * const D)
@{
  D->parent = cclib_exceptional_condition_descriptor_pointer(my_error);
@}
@end example
@end defmac


@defmac cclib_exceptional_condition_object_type (@var{STEM}, @var{VARIANT}, @dots{})
@defmacx cclib_exceptional_condition_object_t (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of an exceptional--condition object type.
@end defmac


@defmac cclib_exceptional_condition_object_is (@var{STEM}, @var{VARIANT}, @dots{})
Expand into the name of a predicate function which, applied to an argument of type
@code{cce_condition_t const *}, returns @ctrue{} if the argument is a pointer to an
exceptional--condition object of type:

@example
cclib_exceptional_condition_object_type (@var{STEM}, @var{VARIANT}, @dots{})
@end example

Usage example:

@example
bool
cclib_exceptional_condition_object_is(my_error) (cce_condition_t const * C)
@{
  return cce_condition_is(C, cclib_exceptional_condition_descriptor_pointer(my_error));
@}
@end example
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c ispell-local-dictionary: "en_GB"
@c End:
