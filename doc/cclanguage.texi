\input texinfo.tex
@c %**start of header
@setfilename cclanguage.info
@settitle CCLanguage
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Document specific macros.
@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCLanguage

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cclanguage

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------------------

@set PackageAutoconfPrefix              CCLANGUAGE
@set PackagePkgconfigModule             cclanguage
@set PackageLibsVar                     @env{CCLANGUAGE_LIBS}
@set PackageCflagsVar                   @env{CCLANGUAGE_CFLAGS}
@c This is the stem of the library in "libcclanguage.so".
@set PackageLibstem                     cclanguage
@set PackageApiPrefixLower              cct_
@set PackageApiPrefixUpper              CCT_

@set PackageHeader                      cclanguage.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set CCLibrariesExamplesUrl    @url{https://github.com/marcomaggi/cclibraries-examples}

@c ------------------------------------------------------------------------

@set CCLibrariesExamples                CCLibraries Examples

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing language adaptations and extensions.  It implements basic definitions used by all the
packages in the CCLibraries project.

The package supports @posix{} platforms.

The code is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cclibraries: (cclibraries).       CCLibraries, C11 language core header file.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* compiler::                    Compiler facilities.
* macros::                      Helper macros.
* typedefs::                    Common type definitions and related macros.
* variadic::                    Variadic preprocessor macros.
* structs::                     Defining data structure handling @api{}.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing language adaptations and extensions.  It implements basic definitions used by all the
packages in the CCLibraries project.

The package supports @posix{} platforms.

The package installs multiple C language header files, of which @file{cclanguage.h} is the main one;
it gives access to the whole @api{}.  All the macro definitions are prefixed with @code{CCLIB_},
@code{cclib_} or @code{cclang_}; all the type names are prefixed with @code{cclib_} and suffixed
with @code{_t}.

Usage examples for this package, and all the CCLibraries packages, are available in the companion
package CCLibraries Examples, @ref{references, CCLibraries Examples} for details.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cclang_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int cclang_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cclang_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int cclang_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node compiler
@chapter Compiler facilities


The interface to the C11 language compiler are defined in the header file
@file{cclanguage-compiler.h}; this header is included by @file{cclanguage.h}.

@menu
* compiler attributes::         Compiler attributes for functions.
* compiler visibility::         Functions and variables visibility declarations.
@end menu

@c page
@node compiler attributes
@section Compiler attributes for functions


@value{PACKAGE} tries to determine, through the C preprocessor macros, which function attributes are
implemented by the compiler and defines the following macros accordingly.  If an attribute is not
implemented: the corresponding macro is defined to expand to the empty string.

A typical function prototype declaration for a function using the facilities of CCLibraries looks
like this:

@example
cclib_decl void * cce_sys_malloc (cce_destination_t L, size_t size)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
  CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
  CCLIB_FUNC_ATTRIBUTE_LEAF;
@end example

@noindent
while a @code{static} and @code{inline} function definition looks like this:

@example
CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
CCLIB_FUNC_ATTRIBUTE_PURE
CCLIB_FUNC_ATTRIBUTE_NONNULL(1)
CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
static inline cce_handler_t *
cce_clean_handler_handler (cce_clean_handler_t * const H)
@{
  ...
@}
@end example


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_ALWAYS_INLINE
Expand into:

@example
__attribute__((__always_inline__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONST
Expand into:

@example
__attribute__((__const__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_CONSTRUCTOR
Expand into:

@example
__attribute__((__constructor__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLEXPORT
Expand into:

@example
__attribute__((__dllexport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_DLLIMPORT
Expand into:

@example
__attribute__((__dllimport__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_FORMAT (...)
Expand into:

@example
__attribute__((__format__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_HOT
Expand into:

@example
__attribute__((__hot__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_LEAF
Expand into:

@example
__attribute__((__leaf__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NONNULL (...)
Expand into:

@example
__attribute__((__nonnull__(__VA_ARGS__)))
@end example

We can use this macro as follows:

@example
cclib_decl void my_func (int * dst, int * src)
  CCLIB_FUNC_ATTRIBUTE_NONNULL(1,2);
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_NORETURN
Expand into:

@example
__attribute__((__noreturn__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_PURE
Expand into:

@example
__attribute__((__pure__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_RETURNS_NONNULL
Expand into:

@example
__attribute__((__returns_nonnull__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_UNUSED
Expand into:

@example
__attribute__((__unused__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_USED
Expand into:

@example
__attribute__((__used__))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_FUNC_ATTRIBUTE_VISIBILITY (...)
Expand into:

@example
__attribute__((__visibility__(__VA_ARGS__)))
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  It expands into:

@example
CCLIB_FUNC_ATTRIBUTE_UNUSED
@end example
@end deffn

@c page
@node compiler visibility
@section Functions and variables visibility declarations


@deffn {Preprocessor Macro} cclib_decl
Expand into the qualifiers for a public @api{} declaration.  When using the @gnu{} C Compiler on a
@posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("default") extern
@end example
@end deffn


@deffn {Preprocessor Macro} cclib_private_decl
Expand into the qualifiers for a private @api{} declaration: entities qualified with this macro are
meant to be visible only inside the namespace of a shared library.  When using the @gnu{} C Compiler
on a @posix{} system, it should expand into:

@example
CCLIB_FUNC_ATTRIBUTE_VISIBILITY("hidden")  extern
@end example
@end deffn

@c page
@node macros
@chapter Helper macros


The following definitions are in the header file @file{cclanguage.h}.


@deffn {Preprocessor Macro} CCLIB_CAST (@var{TYPE}, @var{X}, @var{Y})
Type cast helper.  It expands into:

@example
@var{TYPE} @var{X} = (@var{TYPE}) (@var{Y})
@end example
@end deffn


@deffn {Preprocessor Macro} CCLIB_PC (@var{TYPE}, @var{X}, @var{Y})
Pointer--type cast helper.  It expands into:

@example
@var{TYPE} * @var{X} = (@var{TYPE} *) (@var{Y})
@end example

So, for example, instead of writing:

@example
cce_condition_t * K = cce_condition(L);
cce_exceptional_condition_object_t(ccevents_timeval_invalid) * C = \
  (cce_exceptional_condition_object_t(ccevents_timeval_invalid) *) K;
@end example

@noindent
we can write:

@example
cce_condition_t * K = cce_condition(L);
CCLIB_PC(cce_exceptional_condition_object_t(ccevents_timeval_invalid), C, K);
@end example

@noindent
or:

@example
CCLIB_PC(cce_exceptional_condition_object_t(ccevents_timeval_invalid), C, cce_condition(L));
@end example
@end deffn

@c page
@node typedefs
@chapter Common type definitions and related macros


The C11 language facilities for type definitions are defined in the header file
@file{cclanguage-typedefs.h}; this header is included by @file{cclanguage.h}.

@menu
* typedefs aliases::            Aliases of @posix{} standard types.
* typedefs macros::             Preprocessor macros related to
                                type definitions.
* typedefs opaque::             Opaque data structures handling.
@end menu

@c page
@node typedefs aliases
@section Aliases of @posix{} standard types


All the definitions documented in this section are defined in the header file
@file{cclanguage-typedefs.h}; this header file is included by @file{cclanguage.h}.

@menu
* typedefs aliases types::      @posix{} standard types.
* typedefs aliases limits::     Limits of @posix{} standard types.
* typedefs aliases sizeof::     Size in bytes of @posix{} standard types.
@end menu

@c page
@node typedefs aliases types
@subsection @posix{} standard types


@deftp {Typedef} cclib_sint8_t
An alias for @objtype{int8_t}.
@end deftp


@deftp {Typedef} cclib_uint8_t
An alias for @objtype{uint8_t}.
@end deftp


@deftp {Typedef} cclib_sint16_t
An alias for @objtype{int16_t}.
@end deftp


@deftp {Typedef} cclib_uint16_t
An alias for @objtype{uint16_t}.
@end deftp


@deftp {Typedef} cclib_sint32_t
An alias for @objtype{int32_t}.
@end deftp


@deftp {Typedef} cclib_uint32_t
An alias for @objtype{uint32_t}.
@end deftp


@deftp {Typedef} cclib_sint64_t
An alias for @objtype{int64_t}.
@end deftp


@deftp {Typedef} cclib_uint64_t
An alias for @objtype{uint64_t}.
@end deftp


@deftp {Typedef} cclib_schar_t
An alias for @objtype{signed char}.
@end deftp


@deftp {Typedef} cclib_uchar_t
An alias for @objtype{unsigned char}.
@end deftp


@deftp {Typedef} cclib_sshort_t
An alias for @objtype{signed short int}.
@end deftp


@deftp {Typedef} cclib_ushort_t
An alias for @objtype{unsigned short int}.
@end deftp


@deftp {Typedef} cclib_sint_t
An alias for @objtype{signed int}.
@end deftp


@deftp {Typedef} cclib_uint_t
An alias for @objtype{unsigned int}.
@end deftp


@deftp {Typedef} cclib_slong_t
An alias for @objtype{signed long}.
@end deftp


@deftp {Typedef} cclib_ulong_t
An alias for @objtype{unsigned long}.
@end deftp


@deftp {Typedef} cclib_sllong_t
An alias for @objtype{signed long long}.
@end deftp


@deftp {Typedef} cclib_ullong_t
An alias for @objtype{unsigned long long}.
@end deftp


@deftp {Typedef} cclib_float_t
An alias for @objtype{float}.
@end deftp


@deftp {Typedef} cclib_double_t
An alias for @objtype{double}.
@end deftp


@deftp {Typedef} cclib_ldouble_t
An alias for @objtype{long double}.
@end deftp


@deftp {Typedef} cclib_sintmax_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{intmax_t}.
@end deftp


@deftp {Typedef} cclib_uintmax_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{uintmax_t}.
@end deftp


@deftp {Typedef} cclib_sintptr_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{intptr_t}.
@end deftp


@deftp {Typedef} cclib_uintmax_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{uintmax_t}.
@end deftp


@deftp {Typedef} cclib_ptrdiff_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{ptrdiff_t}.
@end deftp


@deftp {Typedef} cclib_ssize_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{ssize_t}.
@end deftp


@deftp {Typedef} cclib_usize_t
An alias for the @objtype{uintXX_t} type that matches in size the standard @objtype{size_t}.
@end deftp


@deftp {Typedef} cclib_off_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{off_t}.
@end deftp


@deftp {Typedef} cclib_wint_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{wint_t}.
@end deftp


@deftp {Typedef} cclib_wchar_t
An alias for the @objtype{intXX_t} type that matches in size the standard @objtype{wchar_t}.
@end deftp

@c page
@node typedefs aliases limits
@subsection Limits of @posix{} standard types


@deffn {Preprocessor Macro} CCLIB_MIN_SINT8
@deffnx {Preprocessor Macro} CCLIB_MAX_SINT8
Constant limits for the type @objtype{cclib_sint8_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINT8
@deffnx {Preprocessor Macro} CCLIB_MAX_UINT8
Constant limits for the type @objtype{cclib_uint8_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINT16
@deffnx {Preprocessor Macro} CCLIB_MAX_SINT16
Constant limits for the type @objtype{cclib_sint16_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINT16
@deffnx {Preprocessor Macro} CCLIB_MAX_UINT16
Constant limits for the type @objtype{cclib_uint16_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINT32
@deffnx {Preprocessor Macro} CCLIB_MAX_SINT32
Constant limits for the type @objtype{cclib_sint32_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINT32
@deffnx {Preprocessor Macro} CCLIB_MAX_UINT32
Constant limits for the type @objtype{cclib_uint32_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINT64
@deffnx {Preprocessor Macro} CCLIB_MAX_SINT64
Constant limits for the type @objtype{cclib_sint64_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINT64
@deffnx {Preprocessor Macro} CCLIB_MAX_UINT64
Constant limits for the type @objtype{cclib_uint64_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SCHAR
@deffnx {Preprocessor Macro} CCLIB_MAX_SCHAR
Constant limits for the type @objtype{cclib_schar_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UCHAR
@deffnx {Preprocessor Macro} CCLIB_MAX_UCHAR
Constant limits for the type @objtype{cclib_uchar_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SSHORT
@deffnx {Preprocessor Macro} CCLIB_MAX_SSHORT
Constant limits for the type @objtype{cclib_sshort_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_USHORT
@deffnx {Preprocessor Macro} CCLIB_MAX_USHORT
Constant limits for the type @objtype{cclib_ushort_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINT
@deffnx {Preprocessor Macro} CCLIB_MAX_SINT
Constant limits for the type @objtype{cclib_sint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINT
@deffnx {Preprocessor Macro} CCLIB_MAX_UINT
Constant limits for the type @objtype{cclib_uint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SLONG
@deffnx {Preprocessor Macro} CCLIB_MAX_SLONG
Constant limits for the type @objtype{cclib_slong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_ULONG
@deffnx {Preprocessor Macro} CCLIB_MAX_ULONG
Constant limits for the type @objtype{cclib_ulong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SLLONG
@deffnx {Preprocessor Macro} CCLIB_MAX_SLLONG
Constant limits for the type @objtype{cclib_sllong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_ULLONG
@deffnx {Preprocessor Macro} CCLIB_MAX_ULLONG
Constant limits for the type @objtype{cclib_ullong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_FLOAT
@deffnx {Preprocessor Macro} CCLIB_MAX_FLOAT
Constant limits for the type @objtype{cclib_float_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_DOUBLE
@deffnx {Preprocessor Macro} CCLIB_MAX_DOUBLE
Constant limits for the type @objtype{cclib_double_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_LDOUBLE
@deffnx {Preprocessor Macro} CCLIB_MAX_LDOUBLE
Constant limits for the type @objtype{cclib_ldouble_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINTMAX
@deffnx {Preprocessor Macro} CCLIB_MAX_SINTMAX
Constant limits for the type @objtype{cclib_sintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINTMAX
@deffnx {Preprocessor Macro} CCLIB_MAX_UINTMAX
Constant limits for the type @objtype{cclib_uintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SINTPTR
@deffnx {Preprocessor Macro} CCLIB_MAX_SINTPTR
Constant limits for the type @objtype{cclib_sintptr_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_UINTMAX
@deffnx {Preprocessor Macro} CCLIB_MAX_UINTMAX
Constant limits for the type @objtype{cclib_uintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_PTRDIFF
@deffnx {Preprocessor Macro} CCLIB_MAX_PTRDIFF
Constant limits for the type @objtype{cclib_ptrdiff_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_SSIZE
@deffnx {Preprocessor Macro} CCLIB_MAX_SSIZE
Constant limits for the type @objtype{cclib_ssize_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_USIZE
@deffnx {Preprocessor Macro} CCLIB_MAX_USIZE
Constant limits for the type @objtype{cclib_usize_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_OFF
@deffnx {Preprocessor Macro} CCLIB_MAX_OFF
Constant limits for the type @objtype{cclib_off_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_WINT
@deffnx {Preprocessor Macro} CCLIB_MAX_WINT
Constant limits for the type @objtype{cclib_wint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_MIN_WCHAR
@deffnx {Preprocessor Macro} CCLIB_MAX_WCHAR
Constant limits for the type @objtype{cclib_wchar_t}.
@end deffn

@c page
@node typedefs aliases sizeof
@subsection Size in bytes of @posix{} standard types


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINT8
The size in bytes of the type @objtype{cclib_sint8_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINT8
The size in bytes of the type @objtype{cclib_uint8_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINT16
The size in bytes of the type @objtype{cclib_sint16_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINT16
The size in bytes of the type @objtype{cclib_uint16_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINT32
The size in bytes of the type @objtype{cclib_sint32_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINT32
The size in bytes of the type @objtype{cclib_uint32_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINT64
The size in bytes of the type @objtype{cclib_sint64_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINT64
The size in bytes of the type @objtype{cclib_uint64_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SCHAR
The size in bytes of the type @objtype{cclib_schar_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UCHAR
The size in bytes of the type @objtype{cclib_uchar_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SSHORT
The size in bytes of the type @objtype{cclib_sshort_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_USHORT
The size in bytes of the type @objtype{cclib_ushort_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINT
The size in bytes of the type @objtype{cclib_sint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINT
The size in bytes of the type @objtype{cclib_uint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SLONG
The size in bytes of the type @objtype{cclib_slong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_ULONG
The size in bytes of the type @objtype{cclib_ulong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SLLONG
The size in bytes of the type @objtype{cclib_sllong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_ULLONG
The size in bytes of the type @objtype{cclib_ullong_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_FLOAT
The size in bytes of the type @objtype{cclib_float_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_DOUBLE
The size in bytes of the type @objtype{cclib_double_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_LDOUBLE
The size in bytes of the type @objtype{cclib_ldouble_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINTMAX
The size in bytes of the type @objtype{cclib_sintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINTMAX
The size in bytes of the type @objtype{cclib_uintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SINTPTR
The size in bytes of the type @objtype{cclib_sintptr_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_UINTMAX
The size in bytes of the type @objtype{cclib_uintmax_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_PTRDIFF
The size in bytes of the type @objtype{cclib_ptrdiff_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_SSIZE
The size in bytes of the type @objtype{cclib_ssize_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_USIZE
The size in bytes of the type @objtype{cclib_usize_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_OFF
The size in bytes of the type @objtype{cclib_off_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_WINT
The size in bytes of the type @objtype{cclib_wint_t}.
@end deffn


@deffn {Preprocessor Macro} CCLIB_SIZEOF_WCHAR
The size in bytes of the type @objtype{cclib_wchar_t}.
@end deffn

@c page
@node typedefs macros
@section Preprocessor macros related to type definitions


@deffn {Preprocessor Macro} CCLIB_STRUCT_TYPEDEF (@var{STRUCT})
Preprocessor macro that expands into a data structure typedef:

@example
typedef struct @var{STRUCT}      @var{STRUCT}
@end example
@end deffn

@c page
@node typedefs opaque
@section Opaque data structures handling


@anchor{cclib_resource_data_t}
@deftp {Opaque Typedef} cclib_resource_data_t
An alias for @code{void}.
@end deftp


@anchor{cclib_resource_pointer_t}
@deftp {Pointer Typedef} cclib_resource_pointer_t
An alias for @code{cclib_resource_data_t *} we can use to document a pointer to an unspecified data
structure.  It is used, for example, by CCExceptions to reference a resource that must be released
by an exception handler.
@end deftp


@anchor{cclib_resource_pointer}
@deftypefn {Preprocessor Macro} cclib_resource_pointer_t cclib_resource_pointer (void * @var{expr})
Cast to @objtype{cclib_resource_pointer_t} the result of evaluating the expression @var{expr}.
@end deftypefn

@c page
@node variadic
@chapter Variadic preprocessor macros


The following definitions are in the header file @file{cclanguage-variadic-macros.h}; this header
file is included by @file{cclanguage.h}.  The variadic macros machinery implemented in the header
file is derived from code found on Stack Overflow (@aurl{} last accessed Apr 1, 2020):

@center @url{https://stackoverflow.com/a/26408195}

The machinery is composed of a number of preprocessor macros, of which only @cfunc{CCLIB_VNAME} is
public.


@deffn {Preprocessor Macro} CCLIB_VNAME (@var{THING}, @varo{ARG}, @var{ARG}, @dots{})
Expand into a C language name, usable as function, preprocessor macro or whatever; the name has
@var{THING} as prefix and @code{_0}, @code{_1}, @code{_2}, @dots{} as suffix, depending on how many
arguments are in the macro use after the mandatory @var{THING}.  We can use up to 63 arguments,
generating names with suffix from @code{_1} to @code{_63}.

@strong{NOTE} It is @strong{mandatory} to use at least one argument after @var{THING}: @varo{ARG} is
not optional!
@end deffn


We can use the machinery in multiple ways.

@c ------------------------------------------------------------------------

@subsubheading Mimicking variadic functions


With the single macro definition:

@example
#define my_one(...)     CCLIB_VNAME(my_one,__VA_ARGS__)
@end example

@noindent
we can obtain the following expansions:

@example
my_one(7)       @expansion{} my_one_1(7)
my_one(8,9)     @expansion{} my_one_1(8,9)
@end example

@noindent
so we can define the functions:

@example
int
my_one_1 (int arg)
@{
  return arg;
@}

int
my_one_2 (int arg1, int arg2)
@{
  return arg1 + arg2;
@}
@end example

@noindent
and call them as:

@example
my_one(7);
my_one(8, 9);
@end example

@c ------------------------------------------------------------------------

@subsubheading Function names composition

With the following macro definitions:

@example
#define my_two_1(A1)            my_two_ ## A1
#define my_two_2(A1,A2)         my_two_ ## A1 ## _ ## A2
#define my_two(...)             CCLIB_VNAME(my_two,__VA_ARGS__)
@end example

@noindent
we can obtain the following partial expansions:

@example
my_two(alpha)           @expansion{} my_two_1(alpha)
my_two(alpha,beta)      @expansion{} my_two_2(alpha,beta)
@end example

@noindent
and then the final expansions:

@example
my_two_1(alpha)         @expansion{} my_two_alpha
my_two_2(alpha,beta)    @expansion{} my_two_alpha_beta
@end example

So we can define the functions:

@example
int
my_two(alpha) (int arg)
@{
  return arg;
@}

int
my_two(alpha,beta) (int arg1, int arg2, int arg3)
@{
  return arg1 + arg2 + arg3;
@}
@end example

@noindent
and call them as:

@example
my_two(alpha)(1);
my_two(alpha,beta)(1,2,4);
@end example

@c page
@node structs
@chapter Defining data structure handling @api{}


The C11 language facilities for data structure type definitions are defined in the header file
@file{cclanguage-structs.h}; this header is included by @file{cclanguage.h}.

@menu
* structs common::              Well known functions for @struct{} types.
* structs values::              Data structures as values.
* structs methods::             Method tables.
* structs descr::               Data structures with descriptor.
* structs operations::          Common data structure operations.
* structs traits::              Trait data structures.
@end menu

@c page
@node structs common
@section Well known functions for @struct{} types


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by reference'': a set of basic operations on data structures.  Usually we allocate
a data structure on the stack, or embed it into another data structure, or we allocate it on the
heap; then we use a pointer to the structure as argument to functions; this @api{} is for this
scenario.

There is no better way to learn how to use this @api{} than to peruse the examples distributed in
the companion package CCLibraries Examples: they are the files with stem
@code{struct-by-ptr-no-descr}.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_init (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_final (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{init} and @cfunc{final}.

Functions with these names are constructors and destructors for @struct{} instances allocated on the
stack or embedded into enclosing @struct{} instances.  They allocate and release all the
asynchronous resources and initialise the @struct{} fields.

@example
CCLIB_STRUCT_TYPEDEF(my_vector_t);

struct my_vector_t @{
  cclib_usize_t   len;
  cclib_uint8_t * ptr;
@};

void
cclib_init(my_vector_t) (my_vector_t * self, cclib_usize_t len)
@{
  self->len = len;
  self->ptr = calloc(len, sizeof(cclib_uint8_t));
@}

void
cclib_final(my_vector_t) (my_vector_t * self)
@{
  free(self->ptr);
@}
@end example
@end defmac


@defmac cclib_alloc (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_release (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{alloc} nd @cfunc{release}.

Functions with these names are memory allocators and deallocators for @struct{} instances allocated
on the heap.

@example
my_vector_t *
cclib_alloc(my_vector_t) (void)
@{
  return (my_vector_t *)malloc(sizeof(my_vector_t));
@}

void
cclib_release(my_vector_t) (my_vector_t * self)
@{
  free(self);
@}
@end example
@end defmac


@defmac cclib_new (@var{STRUCT}, @var{VARIANT},  @dots{})
@defmacx cclib_delete (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the names of the @api{} functions @cfunc{new} and @cfunc{delete}.

Functions with these names are constructors and destructors for @struct{} instances allocated on the
heap.  The memory allocation is performed by calling the @cfunc{alloc} function; memory deallocation
is performed by calling the function @cfunc{release}.  The initialisation of the fields is performed
by calling the @cfunc{init} function; the finalisation of fields is performed by calling the
@cfunc{final} function.

@example
my_vector_t *
cclib_new(my_vector_t) (cclib_usize_t len)
@{
  my_vector_t * self = cclib_alloc(my_vector_t)();
  cclib_init(my_vector_t)(self, len);
  return self;
@}

void
cclib_delete(my_vector_t) (my_vector_t * self)
@{
  cclib_final(my_vector_t)(self);
  cclib_release(my_vector_t)(self);
@}
@end example
@end defmac

@c page
@node structs values
@section Data structures as values


The following preprocessor macros define the ``well known functions @api{} for common data
structures passed by value'': a set of basic operations on data structures.  Usually we allocate a
data structure then use a pointer to it as argument to functions; but if a data structure is
``small'' we can pass it by value, with no significant overhead; this @api{} is for this scenario.

There is no better way to learn how to use this @api{} than to peruse the examples distributed in
the companion package CCLibraries Examples: they are the files with stem
@code{struct-by-val-no-descr}.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_make (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_unmake (@var{STRUCT}, @var{VARIANT}, @dots{})
Given a data structure type name @var{STRUCT} and an optional variant specification: expand into the
names of the @api{} functions @cfunc{make} and @cfunc{unmake}.

Functions with these names are constructors and destructors for @struct{} instances passed by value.
They allocate and release all the asynchronous resources and initialise the @struct{} fields.

@example
CCLIB_STRUCT_TYPEDEF(my_array_t);

struct my_array_t @{
  cclib_usize_t   len;
  cclib_uint8_t * ptr;
@};

my_array_t
cclib_make(my_array_t) (cclib_usize_t len)
@{
  my_array_t self = @{
    .len = len;
    .ptr = calloc(len, sizeof(cclib_uint8_t));
  @};

  return self;
@}

void
cclib_unmake(my_array_t) (my_array_t self)
@{
  free(self.ptr);
@}
@end example
@end defmac

@c page
@node structs methods
@section Method tables


The following preprocessor macros expand into C language names to organise the definition of
``tables of methods'': data structures whose fields are pointers to functions acting on a specified
data structure type.

Some of these macros are variadic and accept from zero up to three @var{VARIANT} arguments;
@ref{variadic, Variadic preprocessor macros}.


@defmac cclib_methods_table_type (@var{STRUCT}, @var{VARIANT}, @dots{})
@defmacx cclib_methods_table_t (@var{STRUCT}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT} and an optional variant specification: expand into the name of the methods table
type.

@example
struct cclib_methods_table_type(my_vector_t) @{
  cclib_method_type(my_vector_t, destroy) *    destroy;
@};
@end example
@end defmac


@defmac cclib_methods_table (@var{STRUCT_TYPE}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT} and an optional variant specification: expand into the name
of a methods table.  Using the variants: for every table of methods type we can define as many
structure instances as we desire.

@example
static cclib_methods_table_type(my_vector_t) const cclib_methods_table(my_vector_t, embedded) = @{
  .destroy      = cclib_method(my_vector_t, destroy, embedded)
@};

static cclib_methods_table_type(my_vector_t) const cclib_methods_table(my_vector_t, standalone) = @{
  .destroy      = cclib_method(my_vector_t, destroy, standalone)
@};
@end example
@end defmac


@defmac cclib_method_type (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
@defmacx cclib_method_t (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT}, a method name @var{METHOD}, and an optional variant specification: expand into
the type name of that variant of the method function.

In the following usage example we define the type signature of a method's implementation function
and the prototypes of two implementations:

@example
typedef void cclib_method_type(my_vector_t, destroy) (my_vector_t * self);

static cclib_method_type(my_vector_t, destroy) cclib_method(my_vector_t, destroy, embedded);
static cclib_method_type(my_vector_t, destroy) cclib_method(my_vector_t, destroy, standalone);
@end example
@end defmac


@defmac cclib_method (@var{STRUCT}, @var{METHOD}, @var{VARIANT}, @dots{})
Given a data structure name @var{STRUCT}, a method name @var{METHOD}, and an optional variant
specification: expand into the name of that variant of method's implementation function.

@example
void
cclib_method(my_vector_t, destroy, embedded) (my_vector_t * self)
@{
  cclib_final(my_vector_t)(self);
@}

void
cclib_method(my_vector_t, destroy, standalone) (my_vector_t * self)
@{
  cclib_delete(my_vector_t)(self);
@}
@end example
@end defmac

@c page
@node structs descr
@section Data structures with descriptor


A ``data structure with descriptor'' (or struct-with-descr) is just a regular C language data
structure in which a field is itself a data structure defined by the @file{cclanguage-structs.h}
@api{} of preprocessor macros.  It is something like this pseudo--code:

@example
struct cclib_descr_t @{
  ...
@};

struct my_data_t @{
  ...
  struct cclib_descr_t cclib_descr;
  ...
@};
@end example

@noindent
the position of the descriptor field with respect to the other fields does not matter: there is no
requirement of it being the first field.  The descriptor contains meta--informations about the
structure, at present a pointer to a ``table of methods'': a data structure holding pointers to
functions specialised to operate on the structure itself.  We can define a struct-with-descr along
with the common data structures @api{}, @ref{structs common, Well known functions for @struct{}
types}.

If we need more meta--informations for a struct-with-descr, like a data structure name or revision
information: we can implement methods that return such values.

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{struct-by-ptr-with-descr} and
@code{struct-by-val-with-descr}.

Some macros in the following @api{} are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{variadic, Variadic preprocessor macros}.


@defmac CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
a preamble of declarations and definitions required to define a struct-with-descr.  This macro
should be used before declaring the data structure itself.  Usage example:

@example
CCLIB_DEFINE_STRUCT_WITH_DESCRIPTOR(my_complex_t);

struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double        re;
  double        im;
@};
@end example
@end defmac


@defmac cclib_struct_descriptor_type (@var{STRUCT})
@defmacx cclib_struct_descriptor_t (@var{STRUCT})
These two preprocessor macros are aliases: they expand into the same result.  Given a data structure
name @var{STRUCT}, which is meant to be a struct-with-descr: expand into the type name of its
descriptor field.  Usually we do not need to use this macro directly.
@end defmac


@defmac cclib_struct_descriptor (@var{STRUCT})
Given a data structure name @var{STRUCT}, which is meant to be a struct-with-descr: expand into
the descriptor structure field declaration.  We must include a use of this macro in the declaration
of the structure:

@example
struct my_complex_t @{
  cclib_struct_descriptor(my_complex_t);
  double  real_part;
  double  imac_part;
@}
@end example

@noindent
we must use this macro only once in the definition of each struct-with-descr.
@end defmac


@defmac cclib_struct_descriptor_ref_methods_table_pointer (@var{PTR})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): return a
pointer to its methods table usable as both lvalue and rvalue.
@end defmac


@defmac cclib_struct_descriptor_set_methods_table_pointer (@var{PTR}, @var{METHODS_TABLE_POINTER})
Given a pointer do data structure @var{PTR} (which is meant to be a struct-with-descr): set its
pointer to methods table to @var{METHODS_TABLE_POINTER}.  Usage example:

@example
void
cclib_init(my_complex_t, rec) (my_complex_t * S, double re, double im)
@{
  cclib_struct_descriptor_set_methods_table_pointer(S,
    &cclib_methods_table(my_complex_t, embedded));
  S->real_part = re;
  S->imag_part = im;
@}
@end example
@end defmac


@defmac cclib_method_pointer (@var{PTR}, @var{METHOD})
Given a struct type name @var{STRUCT} (which is meant to be a struct-with-descr), a method name
@var{METHOD}: expand into an expression evaluating to a pointer to the method implementation.  Usage
example:

@example
cce_location_t          L[1];
my_complex_t            Z[1];
cce_clean_handler_t     Z_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
  cce_init_and_register_handler(L, Z_H,
    cce_default_clean_handler_function,
    cce_resource_pointer(Z),
    cce_resource_destructor(cclib_method_pointer(Z, destroy)));

  cce_run_body_handlers(L);
@}
@end example
@end defmac


@defmac cclib_call (@var{METHOD}, @var{PTR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{PTR} holding a data structure
pointer (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the pointer @var{PTR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z[1];

cclib_init(my_complex_t, rec)(Z, 1.0, 2.0);
...
cclib_call(destroy, Z);
@end example
@end defmac


@defmac cclib_vcall (@var{METHOD}, @var{VAR}, @dots{})
Given the name of a method @var{METHOD}, the name of a variable @var{VAR} holding a data structure
as value (which is meant to be a struct-with-descr), any number of optional arguments: expand
into an expression that calls the selected method applying it to the value @var{VAR} itself (as
first argument) and the optional arguments.  Usage example:

@example
my_complex_t  Z;

Z = cclib_make(my_complex_t, rec)(1.0, 2.0);
...
cclib_vcall(print, Z, stderr);
@end example
@end defmac

@c page
@node structs operations
@section Common data structure operations


The header file @file{cclanguage-structs.h} defines some macros especially for use with data
structures.  Some of these macros are variadic and accept from zero up to three @var{VARIANT}
arguments; @ref{variadic, Variadic preprocessor macros}.


@defmac cclib_is (@var{STRUCT}, @var{VARIANT},  @dots{})
Given a data structure type name @var{STRUCT}, and an optional variant specification: expand into
the name of the @api{} function @cfunc{is}.

Functions with this name are predicates that return @ctrue{} if their argument is of the given type;
otherwise they return @cfalse{}.  These functions can be implemented only when it is possible to
determine the type of a data structure at run--time.
@end defmac

@c page
@node structs traits
@section Trait data structures


The purpose of traits is to implement a unified interface for some behaviour implemented by
different resources; for example: different C language string implementations might implement the
same ``string'' trait to provide a unified @api{} to some string operations; different file system
pathname implementations might implement the same ``pathname'' trait to provide a unified @api{} to
file system pathname operations.

Traits are data structures with the following characteristics:

@itemize
@item
Traits implement the @file{cclanguage-structs.h} common data structures @api{}.

@item
Traits are passed by value as arguments to functions, @ref{structs values, Data
structures as values}.

@item
Traits have only two fields:

@itemize -
@item
A descriptor as defined by the struct-with-descr @api{}, @ref{structs descr, Data structures with
descriptor}.

@item
A pointer to a resource that the trait operates upon; typically another data structure.
@end itemize

@item
Traits implement a table of methods; every method accepts as first argument the trait data structure
itself, passed by value.  This way every method can call the other methods in the table.

@item
Traits have no state, there must be no trait destructor functions; when we have finished using a
trait: we just forget it like we forget the value of an @objtype{int} or @objtype{double} variable.

@item
While trait data structures hold a pointer to the underlying resource, they do not ``own'' it:
stopping to use a trait data structure must not cause the underlying resource to be destroyed too,
neither must cause the underlying resource to be leaked (it is our responsibility to ensure this).

@item
By convention: we should select, as name of a trait, a C language identifier ending with @code{_T}.
@end itemize

There is no better way to learn how to use this @api{} than to peruse the distributed and installed
examples, they are the files with stem @code{trait}.


@defmac CCLIB_DEFINE_TRAIT (@var{TRAIT})
Define what is needed as preamble for a trait data structure.  To define a new
@objtype{my_destructor_T} trait, we should use this function as:

@example
CCLIB_DEFINE_TRAIT(my_destructor_T);
@end example

To finish the trait definition: we must define a table of methods in the same way we do for a
struct-with-descr, @ref{structs descr, Data structures with descriptor}.
@end defmac


@deftypefn {Preprocessor Macro} {cclib_resource_data_t const *} cclib_trait_resource_pointer (@var{VAR})
Given a trait data structure @var{VAR} as argument: return a pointer to the underlying resource the
@var{TRAIT} operates upon.
@end deftypefn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

The companion package CCLibraries Examples is available from:

@center @value{CCLibrariesExamplesUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c ispell-local-dictionary: "en_GB"
@c End:
